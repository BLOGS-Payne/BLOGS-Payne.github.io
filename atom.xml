<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴志鹏｜Payne-Wu</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://paynewu.com/"/>
  <updated>2021-08-25T13:19:57.831Z</updated>
  <id>https://paynewu.com/</id>
  
  <author>
    <name>吴志鹏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优雅的从服务器上传下载文件</title>
    <link href="https://paynewu.com/ckss9yc9z0045xngoarwv684d.html"/>
    <id>https://paynewu.com/ckss9yc9z0045xngoarwv684d.html</id>
    <published>2021-08-25T02:59:37.000Z</published>
    <updated>2021-08-25T13:19:57.831Z</updated>
    
    <content type="html"><![CDATA[<p><strong>如何优雅的从Linux服务器上进行文件“上传”与“下载”</strong></p><p>不知你是否也遇到以下几种情形：</p><ul>    <li>本地电脑上传文件至Linux服务器</li>    <li>Linux服务器之间文件传递</li></ul><p>那么如何有效、且优雅的的进行呢。特意为了此下载xshell、finalshell等软件？其实也大可不必，隐患太多也并不方便。只需要学会使用Linux中scp命令即可</p><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>scp在网络上的主机之间复制文件。它使用ssh进行数据传输，并使用与ssh相同的身份验证和提供相同的安全性。scp如果身份验证需要密码或密码短语，则会询问密码或密码。</p><p>scp 是加密的，rcp 是不加密的，scp 是 rcp 的加强版。</p><blockquote>    <p>文件名可能包含用户和主机规范，以指示将文件复制到该主机或从该主机复制文件。本地文件名可以使用绝对或相对路径名</p></blockquote><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight shell">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">scp [options] remote_ip:remote_folder(remote_file) local_folder(local_file)</span><br><span class="line">scp [options] remote_user@remote_ip:remote_folder(remote_file) local_folder(local_file)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传</span></span><br><span class="line">scp [options] local_folder(local_file) remote_ip:remote_folder(remote_file)</span><br><span class="line">scp [options] local_folder(local_file) remote_user@remote_ip:remote_folder(remote_file)</span><br></pre>            </td>        </tr>    </table></figure><p><strong>记忆</strong></p><blockquote>    <p>remote_ip 在前即下载，在后即上传</p></blockquote><h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><ul>    <li>-1： 强制scp命令使用协议ssh1</li>    <li>-2： 强制scp命令使用协议ssh2</li>    <li>-4： 强制scp命令只使用IPv4寻址</li>    <li>-6： 强制scp命令只使用IPv6寻址</li>    <li>-B： 使用批处理模式（传输过程中不询问传输口令或短语）</li>    <li>-C： 允许压缩（将-C标志传递给ssh，从而打开压缩功能）</li>    <li>-q： 不显示传输进度条。</li>    <li>-r： 递归复制整个目录。</li>    <li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>    <li>-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li>    <li>-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li>    <li>-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li>    <li>-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。</li>    <li>-o ssh_option： 如果习惯于使用ssh_config中的参数传递方式，</li>    <li>-P port：注意是大写的P, port是指定数据传输用到的端口号</li>    <li>-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p><p>如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p><figure class="highlight shell">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="meta">#</span><span class="bash"> scp 命令使用端口号 4526</span></span><br><span class="line">scp -P 4526 remote@s2:/usr/local/checkNetwokr.sh ~/</span><br></pre>            </td>        </tr>    </table></figure><h2 id="实例脚本"><a href="#实例脚本" class="headerlink" title="实例脚本"></a>实例脚本</h2><p>使用scp实现文件(夹)分发上传到服务器</p><figure class="highlight shell">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 远程地址列表 remote hosts List</span></span></span><br><span class="line">rhs_list=(s1 s2)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 本地文件路径</span></span></span><br><span class="line">local_file=~/c.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 目的文件路径</span></span></span><br><span class="line">target_path=~/</span><br><span class="line"></span><br><span class="line">for host in $&#123;rhs_list[@]&#125;; do</span><br><span class="line">scp -C $&#123;local_file&#125; root@$&#123;host&#125;:~/</span><br><span class="line">done</span><br></pre>            </td>        </tr>    </table></figure><blockquote>    <p>反之也可下载</p></blockquote><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>配合ssh免密登陆与host解析scp更加丝滑哦</p><p>具体可参考基于ssh-key实现服务器免密登陆</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;如何优雅的从Linux服务器上进行文件“上传”与“下载”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不知你是否也遇到以下几种情形：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;本地电脑上传文件至Linux服务器&lt;/li&gt;
    &lt;li&gt;Linux服务器之间文件传递&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="ssh" scheme="https://paynewu.com/categories/ssh/"/>
    
      <category term="Linux" scheme="https://paynewu.com/categories/ssh/Linux/"/>
    
      <category term="服务器" scheme="https://paynewu.com/categories/ssh/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="文件传输" scheme="https://paynewu.com/categories/ssh/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    
      <category term="scp" scheme="https://paynewu.com/categories/ssh/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/scp/"/>
    
    
      <category term="ssh" scheme="https://paynewu.com/tags/ssh/"/>
    
      <category term="Linux" scheme="https://paynewu.com/tags/Linux/"/>
    
      <category term="服务器" scheme="https://paynewu.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="文件传输" scheme="https://paynewu.com/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    
      <category term="scp" scheme="https://paynewu.com/tags/scp/"/>
    
  </entry>
  
  <entry>
    <title>如何做好自我介绍</title>
    <link href="https://paynewu.com/ckss9yca00048xngo074r3mw7.html"/>
    <id>https://paynewu.com/ckss9yca00048xngo074r3mw7.html</id>
    <published>2021-08-24T18:27:34.000Z</published>
    <updated>2021-08-24T19:18:58.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>​ 介，古代传递宾主之言的人。绍，绍继、接续。介绍指相继传话；为人引进或带入新的事物。自我介绍是向别人展示你，认识你。</p><p>​ 自我介绍好不好，重要性不言而喻其直接关系到你给别人的第一印象的好坏及以后交往的顺利与否。同时，也是认识自我的手段。</p><h3 id="如何做好自我介绍"><a href="#如何做好自我介绍" class="headerlink" title="如何做好自我介绍"></a>如何做好自我介绍</h3><p>自我介绍一是为了更好的破冰，让别人记住你、了解你等，那么如何做自我介绍自然也从这几点切入。</p><h3 id="自嘲式"><a href="#自嘲式" class="headerlink" title="自嘲式"></a>自嘲式</h3><blockquote>    <p>适用场景：演讲</p>    <p>关键词：破冰</p></blockquote><p>有趣的自嘲可以快速吸引注意力，让人对你记忆犹新。</p><p>例如：你（大家）好，我叫xxx。原本想做一名x x x,可能是xxx不太好。所以目前做了xxx</p><h3 id="八卦式"><a href="#八卦式" class="headerlink" title="八卦式"></a>八卦式</h3><blockquote>    <p>适用场景：非正式场合</p>    <p>关键词：好奇</p></blockquote><p>在远古社会，智人凭借八卦，使整个群体更趋于稳定和学会更多的协作，而协作就是智人强大起来的秘诀，但是为什么八卦可以使一个族群稳定和协作呢?因为信任，因为八卦这种社交行为可以让智人相互信任，而信任的基础就是相互了解，八卦就是智人相互了解的过程。 ——《人类简史》</p><p>例如：大家好，我叫xxx，来自xxx，（合理热点）结果xxx。我xxx</p><h3 id="自荐式"><a href="#自荐式" class="headerlink" title="自荐式"></a>自荐式</h3><blockquote>    <p>适用场景：商务场合、聚会，面试</p>    <p>关键词：自我推荐</p></blockquote><p>我是xxx，他人最需要自我价值面。</p><blockquote>    <p>切记避免<strong>多次</strong>,尽量全面</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;自我介绍&lt;/h2&gt;
&lt;p&gt;​ 介，古代传递宾主之言的人。绍，绍继、接续。介绍指相继传话；为人引进或带入新的事物。自我介绍是向别人展示你，认识你。&lt;/
      
    
    </summary>
    
    
      <category term="个人随笔" scheme="https://paynewu.com/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
      <category term="所思所想" scheme="https://paynewu.com/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/"/>
    
    
      <category term="个人随笔" scheme="https://paynewu.com/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
      <category term="所思所想" scheme="https://paynewu.com/tags/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>反爬虫常见策略总结</title>
    <link href="https://paynewu.com/ckss9yca2004dxngo0i5najtw.html"/>
    <id>https://paynewu.com/ckss9yca2004dxngo0i5najtw.html</id>
    <published>2021-08-24T17:56:48.000Z</published>
    <updated>2021-08-26T01:45:17.125Z</updated>
    
    <content type="html"><![CDATA[<p>知己知彼，百战不殆 ——《孙子兵法》。</p><blockquote>    <p>本文仅总结鄙人所知的反爬虫方式，不涉猎任何具体的分析与绕过方案。</p></blockquote><h1 id="反爬虫"><a href="#反爬虫" class="headerlink" title="反爬虫"></a>反爬虫</h1><p>反爬虫，即应对爬虫进行反制的统称，<strong>主要区分“正常用户”与“机器人”的一种策略统称</strong>。</p><h2 id="认识反爬虫"><a href="#认识反爬虫" class="headerlink" title="认识反爬虫"></a>认识反爬虫</h2><p>​ 正所谓知其然，知其所以然。对于反爬虫的措施有所了解与认知，一方面便于快捷定位防护点实现分析或绕过，另一方面组成爬虫攻防体系。万变自不离其宗，应对反爬虫措施游刃有余。一般常在如下几大部分<strong>设伏</strong>。</p><blockquote>    <p> 以下便不考虑第三方测试工具的校验</p></blockquote><h3 id="请求前校验"><a href="#请求前校验" class="headerlink" title="请求前校验"></a>请求前校验</h3><h4 id="抓包拦截"><a href="#抓包拦截" class="headerlink" title="抓包拦截"></a><strong>抓包拦截</strong></h4><p>​ 做过爬虫的小伙伴，一定知道在分析加密、执行爬虫项目之前。首先第一步一定是先抓包，定位到对应数据包，然后继续才进行分析或规律。那么在此无疑是<strong>最为有效</strong>的反抓，捕获不到流量包URL未知，除了使用自动化测试工具、RPC等通常可能都毫无办法。</p><p>抓包拦截又可细分为控制台检测、端口转移、证书校验，私有协议总而言之就是让你抓不到包，其方法无所不用其极。</p><p>控制台检测抓包绕过策略：</p><ul>    <li>        <p>替代法: 采用<strong>中间人抓包</strong>（Charles、mitmproxy、firdler等）</p>    </li>    <li>        <p>分析绕过法：定位到检测处，分析绕过</p>    </li></ul><p>端口转移绕过策略：</p><ul>    <li>强制端口</li>    <li>流量转发</li></ul><p><strong>证书锁定与公钥锁定</strong></p><p>​ 为了防止中间人攻击，采用SSL-Pinning的技术来反抓包。 中间人抓包要点是伪造了一个假的证书实现拦截与转发，从而在中间获取的过路数据包实现抓包。<br>反抓思路就是，客户端也预置一份服务端的证书，比较一下就知道真假了。SSL-pinning有两种方式证书锁定（Certificate Pinning）与公钥锁定（Public Key Pinning）</p><p>证书锁定</p><blockquote>    <p>​ 证书锁定是SSL/TLS加密的额外保证手段。它会将服务器的证书公钥预先保存在客户端。在建立安全连接的过程中，客户端会将预置的公钥和接受的证书做比较。<br>如果一致，就建立连接，否则就拒绝连接。在客户端设置证书只允许设置指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书。</p></blockquote><p>公钥锁定</p><blockquote>    <p> HTTP公钥锁定是HTTPS网站防止攻击者CA机构错误签发的证书进行中间人攻击的一种安全机制，用于预防CA遭受入侵或其他会造成CA签发未授权证书的情况。<br>采用公钥锁定时，网站会提供已授权公钥的哈希列表，指示客户端在后续通讯中只接受列表上的公钥。提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。</p></blockquote><p>绕过：Hook到证书校验，无论如何返回正确的即可</p><p><strong>私有协议通讯</strong></p><p>一线大厂自定义通讯协议，自然考虑到了抓包。那么自然而然也设置了反抓包</p><p>绕过：Hook、沙箱</p><h4 id="运行环境检测"><a href="#运行环境检测" class="headerlink" title="运行环境检测"></a>运行环境检测</h4><p>CDN网络分发加验证:经典产品5秒盾</p><blockquote>    <p>其核心为 请求 -&gt; cdn -&gt; 返回关键参数 -&gt; 通过 -&gt; 数据(可能为假)</p></blockquote><h3 id="请求校验"><a href="#请求校验" class="headerlink" title="请求校验"></a>请求校验</h3><blockquote>    <p>当抓到包之后，便是模拟用户请求了。那么这里的常见的反抓措施有哪些呢</p></blockquote><p>请求校验，即在发送请求时即对网络请求时进行校验，实现区分。<strong>通过则返回数据，未通过不返回或返回假数据</strong>常有如下几种方式</p><h4 id="协议校验"><a href="#协议校验" class="headerlink" title="协议校验"></a><strong>协议校验</strong></h4><p>常见通用的协议有HTTP1.0、 HTTP1.1、HTTP2.0 ，若强行只允许HTTP2.0协议来完成请求与响应。那么平常使用其他</p><h4 id="TSL指纹"><a href="#TSL指纹" class="headerlink" title="TSL指纹"></a><strong>TSL指纹</strong></h4><p>每个请求库其实是有自己的库指纹，若只允许某段或某规则指纹通过，那么自然而言实现了反抓的效果。</p><h4 id="header校验"><a href="#header校验" class="headerlink" title="header校验"></a>header校验</h4><p>header校验又可分为两种。其一是字段校验，其二是header字段顺序校验</p><p>header各字段校验，如ua、sign、cookie、token、safe等</p><blockquote>    <p>绕过方案或思想：<br>通过JS解密或逆向获取关键参数缺啥补啥，完成模拟即可</p></blockquote><p>header字段顺序：当我们打开一个网页其实是一个新的会话那么在未断开或重新连接的时候那么这个顺序就是固定的。而字典格式中位置其实是随机分配的，自定义客户端刷新，对header取指纹或字段顺序检测即可实现鉴别</p><blockquote>    <p>绕过方案或思想：保持会话一致</p></blockquote><h4 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h4><p>通常字段不仅在header中校验还经常在请求参数中，如sgin、token、safe等。</p><blockquote>    <p>参数不可无缘无故来，主要来源JS 生成、服务器下发(不限于文件、JS、wasm等)。又可进行多次中间操作</p></blockquote><h4 id="前后端分离技术Ajax"><a href="#前后端分离技术Ajax" class="headerlink" title="前后端分离技术Ajax"></a>前后端分离技术Ajax</h4><blockquote>    <p>严格来说并不算反扒而是前后端分离技术,但常常结合反抓共同出现</p></blockquote><p>Ajax（异步JavaScript和XML）也叫不刷新页面请求。</p><h4 id="RPC防护"><a href="#RPC防护" class="headerlink" title="RPC防护"></a>RPC防护</h4><p>采用RPC及加密或编码方式实现前后端分离、微服务架构等。</p><blockquote>    <p>rpc结合反抓基本步骤，客户端请求(中间极有可能涉猎加密)RPC服务端，RPC客户端(原服务端)再次(中间极有可能涉猎加密)请求(一次或多次)。实现“分端”请求，多端加密。</p>    <p>逆写rpc进行调用，模拟“第一次”客户端请求rpc无差别，绕过</p></blockquote><h4 id="请求校验小结"><a href="#请求校验小结" class="headerlink" title="请求校验小结"></a>请求校验小结</h4><p>通常设置参数有两种情况，</p><ol>    <li>二次或多次请求：<ol>            <li>RPC：客户端请求，服务端使用RPC等再请求。</li>            <li>AJax</li>        </ol>    </li>    <li>JS设置关键参数（<strong>含二次刷新删除源文件跳转页面</strong>）</li></ol><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><ul>    <li>识别点选或输入型</li>    <li>滑轨、滑块型</li>    <li>计算型</li>    <li>空值补齐型</li>    <li>空间推理型</li>    <li>短信或语音验证型</li></ul><h2 id="风控"><a href="#风控" class="headerlink" title="风控"></a>风控</h2><p>范围极大极广，简而言之，用户行为、运行环境等是否<strong>合理</strong>。从而实现区分</p><p>IP封禁</p><p>代码运行环境检测</p><p>等</p><h3 id="数据保护"><a href="#数据保护" class="headerlink" title="数据保护"></a>数据保护</h3><p>在不改变原有展示的情况下实现<strong>“隐藏”</strong></p><p>通常数据保护有以下种方式：</p><ol>    <li>动态字体</li>    <li>CSS偏移</li>    <li>内容加密映射</li>    <li>SVG映射等</li>    <li>内容图片化</li></ol><h2 id="代码防护"><a href="#代码防护" class="headerlink" title="代码防护"></a>代码防护</h2><h3 id="JS代码混淆"><a href="#JS代码混淆" class="headerlink" title="JS代码混淆"></a>JS代码混淆</h3><p>在遇见需要逆向的参数时候，往往不像表面一个参数那般平静。一查看各种混淆、防护又来了。怎么办怎么办，肝啊！当然也可以使用渲染工具模拟，此方案在此便不在过多赘述。</p><p>代码混淆是增加分析难度而牺牲部分性能的一种方案，此方案大部分是体现在通过逻辑转换换等方式将代码转化为难以分析的代码。难以分析是混淆的目的，等价转换是需要确保混淆前后的代码需不影响运行的功能。对于混淆可以又分为如下四种：布局混淆、数据混淆、控制混淆、预防混淆</p><p><strong>布局混淆</strong></p><p>布局混淆指在源代码中删除原有无用代码，处理常量名、变量名函数名等标识符，增加对于代码的阅读与分析。</p><p>无用代码：注释、调试信息、缩进、换行、无用函数与数据等</p><p>处理常量名、变量名函数名等标识符：</p><ul>    <li>标识重命名：将原有代码重命名为无具体意义的字符，例如 将name 重命名为a</li></ul><blockquote>    <p> 注意点：作用域内标识符碰撞情况</p></blockquote><p><strong>小结</strong>：布局混淆并不会影响执行的过程、内存开销，甚至代码体积反而减少了。</p><p><strong>数据混淆</strong></p><p>JS拥有常见的7种数据类型，number、string、boolean、unfined、null、Object</p><p><strong>数字混淆</strong></p><p>数据混淆有常见：进制转换、数字分治、其他</p><ul>    <li>        <p>进制转换：将十进制转化为二进制、八进制、十六进制等，从而达到“混淆”的目的</p>    </li>    <li>        <p><strong>数学分治</strong>：简而言之就是将数拆开，例如 2 = 1 + 1，也等于2 - 1 - 1 + 2再辅以数学公式等</p>    </li>    <li>        <p>其他：重新赋值等</p>    </li></ul><p><strong>字符串混淆</strong></p><p>字符串混淆常见的有编码转换编译、加密。常见的有hash、base64、md5等</p><p><strong>boolean</strong></p><p>我们都知道Boolean值为True、False。根据对boolean的处理，变成难以显示阅读的代码。</p><figure class="highlight plain">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>            </td>            <td class="code">                <pre><span class="line">!0,!1</span><br><span class="line">![], !![]</span><br><span class="line">!&#123;&#125;,!!&#123;&#125;</span><br><span class="line">!NaN,!!NaN</span><br><span class="line">!&quot;&quot;, !!&quot;&quot;</span><br><span class="line">!undefined, !!undefined</span><br><span class="line">!null, !!null</span><br><span class="line">!Object, !!Object</span><br><span class="line">!void(0),!!void(1)</span><br><span class="line"></span><br><span class="line">|,||, &amp;, &amp;&amp;, Boolean()</span><br></pre>            </td>        </tr>    </table></figure><p><strong>控制混淆</strong></p><p>控制混淆是指对程序的控制流进行转换变化，常见的方式有插入僵尸代码、控制流平坦化</p><p>插入僵尸代码：插入僵尸代码即插入无用的代码，增强调试难度</p><p>控制流平坦化：控制流平坦化,将原本的的执行流程平坦化。具体可自行搜索</p><p><strong>预防混淆</strong></p><p>主要体现在 提高反混淆的难度或检测现有混淆器中的漏洞设计</p><h3 id="JS虚拟机"><a href="#JS虚拟机" class="headerlink" title="JS虚拟机"></a>JS虚拟机</h3><p>自定义或定制JavaScript虚拟机，基于给予二进制文件获取结果</p><h3 id="Android-iOS-SDK-加固保护"><a href="#Android-iOS-SDK-加固保护" class="headerlink" title="Android/iOS SDK 加固保护"></a>Android/iOS SDK 加固保护</h3><p><strong>代码混淆</strong></p><blockquote>    <p>具体可参考JS混淆部分，殊归同途</p></blockquote><p><strong>Dex 加固与抽取</strong></p><p>​ Dex 加固即将需要保护的代码单独生成Dex，在so加载时解密jar并通过DexClassLoader加载到内存里。该方案的主要问题在于解密后的Dex会以文件形式存储在手机内存中，而且通过内存dump 的方式能够获取解密后的jar 包，而没有生成文件加载的方式存在很多兼容性的问题</p><p>​ 在实际对抗环境下，Dex 无论如何保护，都有方法还原至原始的Dex，进而反编译得到Java 代码。而C 代码相对而言较难逆向。Java2c 是指将原有的Java 代码抽取出来，通过jni 在native 层反射实现。</p><p>流程如下：Dex→smali→抽取+native 化→生成so</p><p>抽取后的原始Java 函数，反编译出来是native 函数，在运行过程中也不会还原。Java2c 配合C 语言的代码混淆技术和字符串混淆技术，可以对Android 的Java 代码起到很好的保护效果。同时也不需要对原始Java 代码进行重写</p><p><strong>LLVM</strong></p><p>LLVM 是Low Level Virtual Machine 的缩写，其定位是一个比较底层的虚拟机。然而LLVM 本身并不是一个完整的编译器，LLVM 是一个编译器基础架构，把很多编译器需要的功能以可调用的模块形式实现出来并包装成库，其他编译器实现者可以根据自己的需要使用或扩展，主要聚焦于编译器后端功能，如代码生成、代码优化、JIT 等。</p><p><strong>代码虚拟化</strong></p><p>​ 代码虚拟化保护技术是一种比Dex 文件保护、Java2c 技术更强的安全防护技术，可以更有效地对抗逆向工程或破解，避免造成核心技术和风控逻辑被泄密的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br></pre>            </td>            <td class="code">                <pre><span class="line">graph LR</span><br><span class="line">A(已有)&#x3D;&#x3D;无数次的中间转换&#x3D;&#x3D;&gt; B1(所需)</span><br></pre>            </td>        </tr>    </table></figure><p>以上便是本人对于所见所知所想的反爬虫，各种加密、编译、混淆等。中间围绕无数种可能。一起加油吧！！！</p><p>好像什么都说了，什么都没说。望君参考却不限于此。</p><p>总体来说就是抓包、请求前校验、请求校验、数据保护。以及风控、验证码、及对于代码进行保护。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知己知彼，百战不殆 ——《孙子兵法》。&lt;/p&gt;
&lt;blockquote&gt;
    &lt;p&gt;本文仅总结鄙人所知的反爬虫方式，不涉猎任何具体的分析与绕过方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;反爬虫&quot;&gt;&lt;a href=&quot;#反爬虫&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="爬虫" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/"/>
    
      <category term="数据采集" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"/>
    
    
      <category term="爬虫" scheme="https://paynewu.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/tags/Crawler/"/>
    
      <category term="Web Spider" scheme="https://paynewu.com/tags/Web-Spider/"/>
    
      <category term="数据采集" scheme="https://paynewu.com/tags/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的SQL使用之上</title>
    <link href="https://paynewu.com/ckss9yc990026xngo1k9a3v0d.html"/>
    <id>https://paynewu.com/ckss9yc990026xngo1k9a3v0d.html</id>
    <published>2021-08-23T14:37:55.000Z</published>
    <updated>2021-08-24T03:01:14.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL介绍"><a href="#SQL介绍" class="headerlink" title="SQL介绍"></a>SQL介绍</h2><p>结构化查询语言,5.7 以后符合SQL92严格模式,通过sql_mode参数来控制</p><p>DDL（Data Definition Language，数据定义语言）：用于定义数据库、数据表和列，可以用来创建、删除、修改数据库和数据表的结构，包含CREATE、DROP和ALTER等语句。</p><p>DML（Data Manipulation Language，数据操作语言）：用于操作数据记录，可以对数据库中数据表的数据记录进行增加、删除和修改等操作，包含INSERT、DELETE和UPDATE等语句。</p><p>DCL（Data Control Language，数据控制语言）：用于定义数据库的访问权限和安全级别，主要包含GRANT、REVOKE、COMMIT和ROLLBACK等语句。</p><p>DQL（Data Query Language，数据查询语言）：用于查询数据表中的数据记录，主要包含SELECT语句。</p><a id="more"></a><h2 id="DDL的应用"><a href="#DDL的应用" class="headerlink" title="DDL的应用"></a>DDL的应用</h2><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>建库规范：</p><ol>    <li>库名要和业务相关</li>    <li>库名不能有<strong>大写字母</strong>、<strong>数字</strong>开头</li>    <li>建库要加字符集</li></ol><figure class="highlight dart">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br></pre>            </td>            <td class="code">                <pre><span class="line">create database [<span class="keyword">if</span> not exists] 数据库名 [charset 字符编码名称] [collate 排序规则];</span><br></pre>            </td>        </tr>    </table></figure><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><blockquote>    <p>生产中禁止使用</p></blockquote><figure class="highlight dart">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br></pre>            </td>            <td class="code">                <pre><span class="line">drop database 数据库名</span><br></pre>            </td>        </tr>    </table></figure><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><blockquote>    <p>先查在改</p></blockquote><figure class="highlight dart">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br></pre>            </td>            <td class="code">                <pre><span class="line">SHOW CREATE DATABASE 数据库名;</span><br><span class="line">ALTER DATABASE 数据库名 [charset 字符编码名称] [collate 排序规则];</span><br></pre>            </td>        </tr>    </table></figure><blockquote>    <p>注意：修改字符集，修改后的字符集一定是原字符集的严格超集</p></blockquote><h4 id="查（DQL）"><a href="#查（DQL）" class="headerlink" title="查（DQL）"></a>查（DQL）</h4><p>显示所有数据库 形式:show databases;</p><p>显示一个数据库的创建语句: show create database 数据库名;</p><p>其他:show charset; show collation;</p><p>当前选择的数据库:\s、select database();</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p><strong>创建表规范</strong></p><ol>    <li>库名需与业务相关，且小写与非数字开头，表、列均需有注释</li>    <li>注意字符集和存储引擎</li>    <li>选择<strong>合适</strong>的<strong>数据类型</strong></li>    <li>每个列设置为非空，若无法保证非空，用0来填充。</li></ol><h4 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h4><figure class="highlight sql">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 表名(</span><br><span class="line"> 字段<span class="number">1</span> 数据类型 [约束条件] [默认值],</span><br><span class="line"> 字段<span class="number">2</span> 数据类型 [约束条件] [默认值],</span><br><span class="line">  [表约束条件]</span><br><span class="line">) [表选项<span class="number">1</span>,表选项<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># example</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`ch_people_msg`</span> ( </span><br><span class="line">  <span class="string">`p_id`</span>  <span class="built_in">SERIAL</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'用户id'</span> , </span><br><span class="line">  <span class="string">`p_uic`</span> <span class="built_in">CHAR</span>(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span>  <span class="keyword">COMMENT</span> <span class="string">'用户身份证'</span>,</span><br><span class="line">  <span class="string">`p_nickname`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户昵称'</span>, </span><br><span class="line">  <span class="string">`p_gender`</span> ENUM(<span class="string">'m'</span>,<span class="string">'f'</span>, <span class="string">'n'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'n'</span> <span class="keyword">COMMENT</span> <span class="string">'用户性别'</span>, </span><br><span class="line">  <span class="string">`p_age`</span> <span class="built_in">TINYINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'用户年龄'</span>, </span><br><span class="line">  <span class="string">`p_pnum`</span> <span class="built_in">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户电话'</span>, </span><br><span class="line">  <span class="string">`p_address`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户地址'</span>, </span><br><span class="line">  <span class="string">`p_email`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户邮箱'</span>, </span><br><span class="line">  <span class="string">`p_add_time`</span> <span class="built_in">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NOW</span>() <span class="keyword">COMMENT</span> <span class="string">'统计用户时间'</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="string">`p_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_generalci_ci <span class="keyword">COMMENT</span> = <span class="string">'中国成员信息表'</span>;</span><br></pre>            </td>        </tr>    </table></figure><blockquote>    <p>注意：字段结束为<code>,</code>分隔， 整体结束为<code>)</code>分隔</p></blockquote><h4 id="删除-生产中禁用命令"><a href="#删除-生产中禁用命令" class="headerlink" title="删除(生产中禁用命令)"></a>删除(生产中禁用命令)</h4><p>DROP TABLE table_name</p><h3 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h3><figure class="highlight sql">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name [<span class="keyword">ADD</span>、<span class="keyword">DROP</span>、<span class="keyword">MODIFY</span>]</span><br><span class="line"><span class="comment"># 增加字段'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 在表首列加入p_num列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`ch_people_msg`</span> <span class="keyword">ADD</span> p_num <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'数字'</span> <span class="keyword">FIRST</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 在列p_nickname 后增加 p_wechat列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`ch_people_msg`</span> <span class="keyword">ADD</span> p_wechat <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span>  <span class="keyword">COMMENT</span> <span class="string">'微信号'</span> <span class="keyword">AFTER</span> <span class="string">`p_nickname`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 在表中(最后)增加p_qq列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`ch_people_msg`</span> <span class="keyword">ADD</span> p_qq <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span> <span class="keyword">COMMENT</span> <span class="string">'用户qq号'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> 字段名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">MODIFY</span> 字段名 约束条件 默认值</span><br></pre>            </td>        </tr>    </table></figure><h4 id="表属性查询（DQL）"><a href="#表属性查询（DQL）" class="headerlink" title="表属性查询（DQL）"></a>表属性查询（DQL）</h4><figure class="highlight sql">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="comment"># 罗列所有表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>；</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看表状态</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> [<span class="keyword">from</span> db_name] [<span class="keyword">like</span> table_name];</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看表结构</span></span><br><span class="line">desc `table_name`;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看创建表语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`table_name`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建相同类型的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`db_name_2`</span> <span class="keyword">LIKE</span> <span class="string">`db_name_1`</span>;</span><br></pre>            </td>        </tr>    </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SQL介绍&quot;&gt;&lt;a href=&quot;#SQL介绍&quot; class=&quot;headerlink&quot; title=&quot;SQL介绍&quot;&gt;&lt;/a&gt;SQL介绍&lt;/h2&gt;
&lt;p&gt;结构化查询语言,5.7 以后符合SQL92严格模式,通过sql_mode参数来控制&lt;/p&gt;
&lt;p&gt;DDL（Data Definition Language，数据定义语言）：用于定义数据库、数据表和列，可以用来创建、删除、修改数据库和数据表的结构，包含CREATE、DROP和ALTER等语句。&lt;/p&gt;
&lt;p&gt;DML（Data Manipulation Language，数据操作语言）：用于操作数据记录，可以对数据库中数据表的数据记录进行增加、删除和修改等操作，包含INSERT、DELETE和UPDATE等语句。&lt;/p&gt;
&lt;p&gt;DCL（Data Control Language，数据控制语言）：用于定义数据库的访问权限和安全级别，主要包含GRANT、REVOKE、COMMIT和ROLLBACK等语句。&lt;/p&gt;
&lt;p&gt;DQL（Data Query Language，数据查询语言）：用于查询数据表中的数据记录，主要包含SELECT语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://paynewu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://paynewu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://paynewu.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://paynewu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据类型</title>
    <link href="https://paynewu.com/ckss9yc95001yxngo725g0rxf.html"/>
    <id>https://paynewu.com/ckss9yc95001yxngo725g0rxf.html</id>
    <published>2021-08-21T15:07:19.000Z</published>
    <updated>2021-08-24T03:01:14.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><p>MySQL支持丰富的数据类型，总体上可以分为数值类型、日期和时间类型、字符串类型。</p><p>数值类型包括整数类型、浮点数类型和定点数类型；字符串类型包括文本字符串类型和二进制字符串类型;</p><p>具体入下所示</p><p>主要包括以下几大类：<br>数值类型：</p><ul>    <li>        <p>BIT、BOOL、TINYINT、SMALLINT、MEDIUM INT、 INT、 BIG INT、</p>    </li>    <li>        <p>FLOAT、DOUBLE、DECIMAL(浮点数类型)</p>    </li></ul><p>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB、ENUM、SET</p><p>日期类型：Date、DateTime、TimeStamp、Time、Year</p><p>空间类型：Geometry、Point、LineString、MultiPoint、MultiLineString、MultiPolyGon、Polygon、GeometryCollection</p><p>其他类型：JSON</p><a id="more"></a><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><blockquote>    <p>一个字节是8位</p>    <p>无符号（UNSIGNED）为翻倍</p></blockquote><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>MySQL中的整数类型包括TINYINT、SMALLINT、MEDIUMINT、INT(INTEGER)和BIGINT。不同的整数类型，其所需要的存储空间和数值范围不尽相同</p><div class="table-container">    <table>        <thead>            <tr>                <th style="text-align:center">数值类型</th>                <th style="text-align:center">类型名称</th>                <th style="text-align:center">存储空间</th>                <th style="text-align:center">取值范围</th>            </tr>        </thead>        <tbody>            <tr>                <td style="text-align:center">TINY INT</td>                <td style="text-align:center">非常小的整数</td>                <td style="text-align:center">1个字节</td>                <td style="text-align:center">- 2 ^ 7 ~ 2 ^ 7 -1</td>            </tr>            <tr>                <td style="text-align:center">SMALL INT</td>                <td style="text-align:center">小整数</td>                <td style="text-align:center">2个字节</td>                <td style="text-align:center">- 2 ^ 15 ~ 2 ^ 15 -1</td>            </tr>            <tr>                <td style="text-align:center">MEDIUM INT</td>                <td style="text-align:center">中型的整数</td>                <td style="text-align:center">3个字节</td>                <td style="text-align:center">- 2 ^ 23 ~ 2 ^ 23 -1</td>            </tr>            <tr>                <td style="text-align:center">INT</td>                <td style="text-align:center">整数</td>                <td style="text-align:center">4个字节</td>                <td style="text-align:center">- 2 ^ 31 ~ 2 ^ 31 -1</td>            </tr>            <tr>                <td style="text-align:center">BIG INT</td>                <td style="text-align:center">大整数</td>                <td style="text-align:center">8个字节</td>                <td style="text-align:center">- 2 ^ 63 ~ 2 ^ 63 - 1</td>            </tr>        </tbody>    </table></div><blockquote>    <p>整数类型的显示宽度与数据类型的取值范围无关。</p>    <p>显示宽度只是指定最大显示的数字个数，如果在数据表中插入了大于显示宽度，但是并没有超过整数类型的数值范围的数据，依然可以正确地插入数据，并且能够正确地显示</p></blockquote><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><div class="table-container">    <table>        <thead>            <tr>                <th style="text-align:center">数值类型</th>                <th style="text-align:center">类型名称</th>                <th style="text-align:center">存储空间</th>                <th style="text-align:center">取值范围</th>                <th>说明</th>            </tr>        </thead>        <tbody>            <tr>                <td style="text-align:center">DECIMAL(M,D)</td>                <td style="text-align:center">定点数类型</td>                <td style="text-align:center">M + 1 <br />或 <br />M + 2</td>                <td style="text-align:center">~</td>                <td>未打包的浮点数，用法类似于FLOAT与DOUBLE<br />浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。</td>            </tr>            <tr>                <td style="text-align:center">FLOAT</td>                <td style="text-align:center">单精度浮点类型</td>                <td style="text-align:center">4 个字节</td>                <td style="text-align:center">2 ^ 31 ~2 ^ 31 - 1</td>                <td>~</td>            </tr>            <tr>                <td style="text-align:center">DOUBLE</td>                <td style="text-align:center">双精度浮点类型</td>                <td style="text-align:center">8 个字节</td>                <td style="text-align:center">2 ^61 ~2 ^ 61 - 1</td>                <td>~</td>            </tr>        </tbody>    </table></div><blockquote>    <p>浮点数类型中的FLOAT和DOUBLE类型在不指定数据精度时，默认会按照实际的计算机硬件和操作系统决定的数据精度进行显示。如果用户指定的精度超出了浮点数类型的数据精度，则MySQL会自动进行四舍五入操作。</p></blockquote><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><div class="table-container">    <table>        <thead>            <tr>                <th style="text-align:center">数值类型</th>                <th style="text-align:center">类型名称</th>                <th style="text-align:center">存储空间</th>                <th style="text-align:center">说明</th>            </tr>        </thead>        <tbody>            <tr>                <td style="text-align:center">BOOL</td>                <td style="text-align:center">布尔类型</td>                <td style="text-align:center">1字节</td>                <td style="text-align:center">TINY INT(1)的别名</td>            </tr>            <tr>                <td style="text-align:center">BIT</td>                <td style="text-align:center">位类型</td>                <td style="text-align:center"></td>                <td style="text-align:center">位类型(M), 每个值存储M位，默认为1，最大64</td>            </tr>            <tr>                <td style="text-align:center">SERIAL</td>                <td style="text-align:center">无符号大整数</td>                <td style="text-align:center">8 个字节</td>                <td style="text-align:center">BIG INT UNSIGNED NOT NULL AUTO_INCREMEINT UNIQUE</td>            </tr>        </tbody>    </table></div><p>浮点数类型中的FLOAT类型和DOUBLE类型在不指定精度时，默认会按照计算机硬件和操作系统决定的精度进行表示；而定点数类型中的DECIMAL类型不指定精度时，默认为DECIMAL(10,0)。</p><p>当数据类型的长度一定时，浮点数能够表示的数据范围更大，但是浮点数会引起精度问题，不适合存储高精度类型的数据。</p><h3 id="文本类型"><a href="#文本类型" class="headerlink" title="文本类型"></a>文本类型</h3><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><div class="table-container">    <table>        <thead>            <tr>                <th style="text-align:center">字符类型</th>                <th style="text-align:center">类型名称</th>                <th style="text-align:center">存储空间</th>            </tr>        </thead>        <tbody>            <tr>                <td style="text-align:center">CHAR</td>                <td style="text-align:center">字符类型</td>                <td style="text-align:center">固定长度字符串，最多为255字符</td>            </tr>            <tr>                <td style="text-align:center">VARCHAR</td>                <td style="text-align:center">可变字符类型</td>                <td style="text-align:center">可变长字符串，最多为65,535字符</td>            </tr>            <tr>                <td style="text-align:center">TINYTEXT</td>                <td style="text-align:center">短文本类型</td>                <td style="text-align:center">可变长度字符串，最多为255字符</td>            </tr>            <tr>                <td style="text-align:center">TEXT</td>                <td style="text-align:center">文本类型</td>                <td style="text-align:center">可变长度字符串，最多为65,535字符</td>            </tr>            <tr>                <td style="text-align:center">MEDIUMTEXT</td>                <td style="text-align:center">中等文本类型</td>                <td style="text-align:center">可变长度，最多为16,777,215 字符</td>            </tr>            <tr>                <td style="text-align:center">LONGTEXT</td>                <td style="text-align:center">长文本类型</td>                <td style="text-align:center">可变长度，最多为4,294,967,295字符</td>            </tr>        </tbody>    </table></div><p><strong>char和varchar</strong></p><ol>    <li>        <p>char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。 </p>    </li>    <li>        <p>char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。 </p>    </li>    <li>char类型的字符串检索速度要比varchar类型的快。</li></ol><p><strong>varchar和text</strong></p><ol>    <li>        <p>varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字节。 </p>    </li>    <li>        <p>text类型不能有默认值。 </p>    </li>    <li>varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。</li></ol><h4 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h4><div class="table-container">    <table>        <thead>            <tr>                <th style="text-align:center">类型</th>                <th style="text-align:center">类型名称</th>                <th style="text-align:center">占位</th>                <th style="text-align:center">说明</th>            </tr>        </thead>        <tbody>            <tr>                <td style="text-align:center">BINARY</td>                <td style="text-align:center">二进制字符</td>                <td style="text-align:center"></td>                <td style="text-align:center">类似于CHAR（固定长度）类型，但存储的是<strong>二进制字节字符串</strong></td>            </tr>            <tr>                <td style="text-align:center">VARBINARY</td>                <td style="text-align:center">可变二进制字符</td>                <td style="text-align:center"></td>                <td style="text-align:center">类似于VARCHAR（可变长度）类型，但存储的是<strong>二进制字节字符串</strong></td>            </tr>            <tr>                <td style="text-align:center">TINYBLOB</td>                <td style="text-align:center">较小的大二进制对象</td>                <td style="text-align:center">1</td>                <td style="text-align:center">最大长度255的字节的BLOB序列<br />存储时在内容前将使用1个字节表示内容的大小</td>            </tr>            <tr>                <td style="text-align:center">BLOB</td>                <td style="text-align:center">大二进制对象</td>                <td style="text-align:center">2</td>                <td style="text-align:center">最大长度63535的字节的BLOB序列<br />存储时在内容前将使用2个字节表示内容的大小</td>            </tr>            <tr>                <td style="text-align:center">MEDIUM BLOB</td>                <td style="text-align:center">中等大的大二进制对象</td>                <td style="text-align:center">3</td>                <td style="text-align:center">最大长度1677215的字节的BLOB序列<br />存储时在内容前将使用3个字节表示内容的大小</td>            </tr>            <tr>                <td style="text-align:center">LONG BLOB</td>                <td style="text-align:center">大的大二进制对象</td>                <td style="text-align:center">4</td>                <td style="text-align:center">最大长度4294967296的字节的BLOB序列<br />存储时在内容前将使用4个字节表示内容的大小</td>            </tr>        </tbody>    </table></div><p>二进制数据(Blob)</p><p>1._BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。</p><p>2._BLOB存储的数据只能整体读出。 </p><p>3._TEXT可以指定字符集，_BLO不用指定字符集。</p><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><div class="table-container">    <table>        <thead>            <tr>                <th style="text-align:center">类型</th>                <th style="text-align:center">类型名称</th>                <th style="text-align:center">说明</th>            </tr>        </thead>        <tbody>            <tr>                <td style="text-align:center">ENUM</td>                <td style="text-align:center">枚举类型</td>                <td style="text-align:center">由一组固定的合法值组成的枚举</td>            </tr>            <tr>                <td style="text-align:center">SET</td>                <td style="text-align:center">集合类型</td>                <td style="text-align:center">由一组固定的合法值组成的集合</td>            </tr>        </tbody>    </table></div><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><p>MySQL提供了表示日期和时间的数据类型，主要有YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。</p><ul>    <li>        <p>DATE类型通常用来表示年月日；</p>    </li>    <li>        <p>DATETIME类型通常用来表示年、月、日、时、分、秒；</p>    </li>    <li>        <p>TIME类型通常用来表示时、分、秒。</p>    </li></ul><div class="table-container">    <table>        <thead>            <tr>                <th style="text-align:center">时间/日期类型</th>                <th style="text-align:center">类型名称</th>                <th style="text-align:center">占位</th>                <th style="text-align:center">日期格式</th>            </tr>        </thead>        <tbody>            <tr>                <td style="text-align:center">YEAR</td>                <td style="text-align:center">年</td>                <td style="text-align:center">1个字节</td>                <td style="text-align:center">YYYY</td>            </tr>            <tr>                <td style="text-align:center">TIME</td>                <td style="text-align:center">时间</td>                <td style="text-align:center">3个字节</td>                <td style="text-align:center">HH:MM:SS</td>            </tr>            <tr>                <td style="text-align:center">DATE</td>                <td style="text-align:center">日期</td>                <td style="text-align:center">3个字节</td>                <td style="text-align:center">YYYY—MM-DD</td>            </tr>            <tr>                <td style="text-align:center">TIMESTEAMP</td>                <td style="text-align:center">日期时间</td>                <td style="text-align:center">4个字节</td>                <td style="text-align:center">YYYY—MM-DD HH:MM:SS</td>            </tr>            <tr>                <td style="text-align:center">DATETIME</td>                <td style="text-align:center">日期时间</td>                <td style="text-align:center">8个字节</td>                <td style="text-align:center">YYYY—MM-DD HH:MM:SS</td>            </tr>        </tbody>    </table></div><blockquote>    <p>若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间</p>    <p>每种日期和时间类型都有一个有效值范围，如果超出这个有效值范围，则会以0进行存储</p></blockquote><h3 id="空间类型"><a href="#空间类型" class="headerlink" title="空间类型"></a>空间类型</h3><p>Geometry：存储任意几何体类型<br>Point：存储二维中的点类型<br>LineString：存储点之间的线型插值曲线类型<br>MultiPoint：存储点的集合类型<br>MultiLineString：存储点之间的线型插值曲线集合类型<br>MultiPolyGon：存储多边形集合类型<br>Polygon：存储多边形类型<br>GeometryCollection：存储任意类型集合体的集合类型</p><h3 id="数据类型的属性"><a href="#数据类型的属性" class="headerlink" title="数据类型的属性"></a>数据类型的属性</h3><h4 id="MySQL关键字-含义"><a href="#MySQL关键字-含义" class="headerlink" title="MySQL关键字 含义"></a>MySQL关键字 含义</h4><p>NULL 数据列可包含NULL值<br>NOT NULL 数据列不允许包含NULL值<br>DEFAULT 默认值<br>PRIMARY KEY 主键<br>AUTO_INCREMENT 自动递增，适用于整数类型<br>UNSIGNED 无符号<br>CHARACTER SET name 指定一个字符集</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL数据类型&quot;&gt;&lt;a href=&quot;#MySQL数据类型&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据类型&quot;&gt;&lt;/a&gt;MySQL数据类型&lt;/h2&gt;
&lt;p&gt;MySQL支持丰富的数据类型，总体上可以分为数值类型、日期和时间类型、字符串类型。&lt;/p&gt;
&lt;p&gt;数值类型包括整数类型、浮点数类型和定点数类型；字符串类型包括文本字符串类型和二进制字符串类型;&lt;/p&gt;
&lt;p&gt;具体入下所示&lt;/p&gt;
&lt;p&gt;主要包括以下几大类：&lt;br&gt;数值类型：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;
        &lt;p&gt;BIT、BOOL、TINYINT、SMALLINT、MEDIUM INT、 INT、 BIG INT、&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;p&gt;FLOAT、DOUBLE、DECIMAL(浮点数类型)&lt;/p&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB、ENUM、SET&lt;/p&gt;
&lt;p&gt;日期类型：Date、DateTime、TimeStamp、Time、Year&lt;/p&gt;
&lt;p&gt;空间类型：Geometry、Point、LineString、MultiPoint、MultiLineString、MultiPolyGon、Polygon、GeometryCollection&lt;/p&gt;
&lt;p&gt;其他类型：JSON&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://paynewu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://paynewu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://paynewu.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://paynewu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库体系结构</title>
    <link href="https://paynewu.com/ckss9yc980022xngo33auhfwn.html"/>
    <id>https://paynewu.com/ckss9yc980022xngo33auhfwn.html</id>
    <published>2021-08-21T02:42:42.000Z</published>
    <updated>2021-08-24T03:01:14.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><h3 id="C-S-Client-Server-模型"><a href="#C-S-Client-Server-模型" class="headerlink" title="C/S(Client/Server)模型"></a>C/S(Client/Server)模型</h3><p>​ C/S结构是一种软件系统体系结构，</p><p>​ C是英文单词“Client”的首字母，即客户端的意思，C/S就是“Client/Server”的缩写，即“客户端/服务器”模式。MySQL C/S 可如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gto7tgqgp1j60js0a8jrl02.jpg" alt=""></p><h4 id="MySQL-连接"><a href="#MySQL-连接" class="headerlink" title="MySQL 连接"></a>MySQL 连接</h4><p>实现MySQL连接的方式主要有两种，</p><ul>    <li>基于TCP/IP的连接，适用于远程、本地</li>    <li>基于Socket方式连接，仅限于本地连接</li></ul><figure class="highlight sh">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="comment"># TCP/IP方式（远程、本地）</span></span><br><span class="line">mysql -h 192.168.0.51 -P 3306 -u root -p paynepasswd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Socket方式(仅本地)</span></span><br><span class="line">mysql -S /tmp/mysql.sock -u root -p paynepasswd</span><br></pre>            </td>        </tr>    </table></figure><a id="more"></a><p>在Linux中<code>/etc/my.cnf</code>文件中显示（已完成MySQL的安装）</p><figure class="highlight sh">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>            </td>            <td class="code">                <pre><span class="line">socket=/tmp/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/my.cnf    示例如下                                                                                    </span></span><br><span class="line">[client]</span><br><span class="line"><span class="comment">#password       = your_password</span></span><br><span class="line">port            = 3306</span><br><span class="line">socket          = /tmp/mysql.sock</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">port            = 3306</span><br><span class="line">socket          = /tmp/mysql.sock</span><br><span class="line">datadir = /www/server/data</span><br><span class="line">default_storage_engine = InnoDB</span><br><span class="line">performance_schema_max_table_instances = 400</span><br><span class="line">table_definition_cache = 400</span><br><span class="line">skip-external-locking</span><br><span class="line">key_buffer_size = 1024M</span><br><span class="line"></span><br><span class="line">---略</span><br></pre>            </td>        </tr>    </table></figure><h2 id="服务器端-实例"><a href="#服务器端-实例" class="headerlink" title="服务器端(实例):"></a>服务器端(实例):</h2><p>实例：My sqld + 工作线程 + 预分配内存 </p><p>功能：管理数据(增删改查等)</p><h3 id="mysqld逻辑结构"><a href="#mysqld逻辑结构" class="headerlink" title="mysqld逻辑结构"></a>mysqld逻辑结构</h3><p>mysqld的工作模型可分为两块，<code>server</code>层，<code>引擎层</code>，server层可细分为<code>连接层</code>、<code>SQL层</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtoa5gogpej60fv0dhjs202.jpg" alt=""></p><h4 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h4><ul>    <li>提供连接协议（socket、TCP/IP）</li>    <li>验证用户（账号名、密码、权限）</li>    <li>提供用户专用线程</li></ul><h4 id="SQL层"><a href="#SQL层" class="headerlink" title="SQL层"></a>SQL层</h4><ul>    <li>接收上层传送的SQL语句</li>    <li>语法验证模块：验证语句语法,是否满足SQL_MODE</li>    <li>语义检查：判断SQL语句的类型(DDL、DCL、DML、DQL)</li>    <li>执行权限检查：对语句执行前,进行预处理，生成解析树(执行计划)</li>    <li>优化器：根据解析器得出的多种执行计划，进行判断，选择最优的执行计划        <pre><code>    代价模型：资源（CPU IO MEM）的耗损评估性能好坏</code></pre>    </li>    <li>执行器：根据最优执行计划，执行SQL语句，产生执行结果</li>    <li>提供查询缓存（默认是没开启的）常使用redis、tair替代查询缓存功能</li>    <li>提供日志记录（日志管理章节）：binlog，默认是没开启的。</li></ul><h4 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h4><blockquote>    <p>类似于Linux中的文件系统</p></blockquote><ul>    <li>负责根据SQL层执行的结果，从磁盘上拿数据</li>    <li>将16进制的磁盘数据，交由SQL结构化化成表</li>    <li>连接层的专用线程返回给用户</li></ul><h2 id="数据库逻辑结构"><a href="#数据库逻辑结构" class="headerlink" title="数据库逻辑结构"></a>数据库逻辑结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/16956686-127fff46fdb7fea9.png" alt=""></p><ul>    <li>库：库名，库属性</li>    <li>表：表名、属性、<ul>            <li>列:列名(字段),列属性(数据类型,约束等)</li>            <li>数据行(记录)</li>        </ul>    </li></ul><p><img src="https://upload-images.jianshu.io/upload_images/16956686-bfd40838aef7971b.png" alt="物理结构"></p><p>库的物理存储结构</p><ul>    <li>用文件系统的目录来存储</li></ul><p>表的物理存储结构</p><figure class="highlight plain">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>            </td>            <td class="code">                <pre><span class="line">MyISAM（一种引擎）的表：</span><br><span class="line">-rw-r----- 1 mysql mysql   10816 Apr 18 8:37 user.frm</span><br><span class="line">-rw-r----- 1 mysql mysql     396 Apr 18 11:20  user.MYD</span><br><span class="line">-rw-r----- 1 mysql mysql    4096 Apr 18 17:48 user.MYI</span><br><span class="line"></span><br><span class="line">InnoDB(默认的存储引擎)的表：</span><br><span class="line">-rw-r----- 1 mysql mysql    8636 Apr 18 9:37 time_zone.frm</span><br><span class="line">-rw-r----- 1 mysql mysql   98304 Apr 18 1:37 time_zone.ibd</span><br><span class="line">time_zone.frm：存储列相关信息</span><br><span class="line">time_zone.ibd：数据行+索引</span><br></pre>            </td>        </tr>    </table></figure><p>表的段、区、页（16k）</p><figure class="highlight plain">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>            </td>            <td class="code">                <pre><span class="line">页：最小的存储单元，默认16k</span><br><span class="line">区：64个连续的页，共1M</span><br><span class="line">段：一个表就是一个段，包含一个或多个区</span><br></pre>            </td>        </tr>    </table></figure><h2 id="执行SQL流程"><a href="#执行SQL流程" class="headerlink" title="执行SQL流程"></a>执行SQL流程</h2><blockquote>    <p>假设忽略权限验证、表操作验证</p></blockquote><ol>    <li>        <p>客户端发送一条SQL语句给MySQL服务器。</p>    </li>    <li>        <p>MySQL服务器先检查查询缓存，如果查询缓存中存在待查询的结果数据，则会立刻返回查询缓存中的结果数据，否则执行下一阶段的处理。</p>    </li>    <li>        <p>MySQL服务器通过解析器和预处理器对SQL语句进行解析和预处理，并将生成的SQL语句解析树传递给查询优化器。</p>    </li>    <li>        <p>查询优化器将SQL解析树进行进一步处理，生成对应的执行计划。</p>    </li>    <li>        <p>MySQL服务器根据查询优化器生成的执行计划，通过查询执行引擎调用存储引擎的API来执行查询操作。</p>    </li>    <li>        <p>存储引擎查询数据库中的数据，并将结果返回给查询执行引擎。</p>    </li>    <li>        <p>查询执行引擎将结果保存在查询缓存中，并通过数据库连接/线程处理返回给客户端。</p>    </li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtoc99udhyj60bw0ma0tu02.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL体系结构&quot;&gt;&lt;a href=&quot;#MySQL体系结构&quot; class=&quot;headerlink&quot; title=&quot;MySQL体系结构&quot;&gt;&lt;/a&gt;MySQL体系结构&lt;/h2&gt;
&lt;h3 id=&quot;C-S-Client-Server-模型&quot;&gt;&lt;a href=&quot;#C-S-Client-Server-模型&quot; class=&quot;headerlink&quot; title=&quot;C/S(Client/Server)模型&quot;&gt;&lt;/a&gt;C/S(Client/Server)模型&lt;/h3&gt;
&lt;p&gt;​ C/S结构是一种软件系统体系结构，&lt;/p&gt;
&lt;p&gt;​ C是英文单词“Client”的首字母，即客户端的意思，C/S就是“Client/Server”的缩写，即“客户端/服务器”模式。MySQL C/S 可如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008i3skNgy1gto7tgqgp1j60js0a8jrl02.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;MySQL-连接&quot;&gt;&lt;a href=&quot;#MySQL-连接&quot; class=&quot;headerlink&quot; title=&quot;MySQL 连接&quot;&gt;&lt;/a&gt;MySQL 连接&lt;/h4&gt;
&lt;p&gt;实现MySQL连接的方式主要有两种，&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;基于TCP/IP的连接，适用于远程、本地&lt;/li&gt;
    &lt;li&gt;基于Socket方式连接，仅限于本地连接&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td class=&quot;gutter&quot;&gt;
                &lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;
            &lt;/td&gt;
            &lt;td class=&quot;code&quot;&gt;
                &lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# TCP/IP方式（远程、本地）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql -h 192.168.0.51 -P 3306 -u root -p paynepasswd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Socket方式(仅本地)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql -S /tmp/mysql.sock -u root -p paynepasswd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://paynewu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://paynewu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://paynewu.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://paynewu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库一些概念</title>
    <link href="https://paynewu.com/ckss9yc94001vxngo7yaq4pdp.html"/>
    <id>https://paynewu.com/ckss9yc94001vxngo7yaq4pdp.html</id>
    <published>2021-08-21T02:04:42.000Z</published>
    <updated>2021-08-24T03:01:14.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库一些概念"><a href="#MySQL数据库一些概念" class="headerlink" title="MySQL数据库一些概念"></a>MySQL数据库一些概念</h1><h2 id="数据库的定义"><a href="#数据库的定义" class="headerlink" title="数据库的定义"></a>数据库的定义</h2><p>​ 数据库的定义在某种程度上，数据库代表着一种存储技术，并不局限于某种存储形式。一个简单的数据库可以将数据只存储在某台特定的计算机上，供某个特定的用户使用，而一个复杂的数据库可以将数据分散存储到多台计算机上，能够供成千上万的用户同时使用。从存储容量上来说，一个数据库的存储容量可以小到只能够存储几KB的数据，也可以大到存储TB甚至是PB级别的数据。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>​ 数据库（DataBase，DB）从本质上讲就是一个文件系统，它能够将数据有组织地集合在一起，按照一定的规则长期存储到计算机的磁盘中，并且能够供多个用户共享和使用，同时，用户能够对数据库中的数据进行插入、删除、修改和查询操作。数据库将数据进行集中存储和管理，有效地分离了应用程序和业务数据，降低了应用程序和业务数据之间的耦合性，大大简化了数据的存储和管理工作。同时，数据库提供了对存储数据的统一控制功能。数据除了能够被存储在计算机的磁盘中，还能够被存储在计算机的内存中，所以在某种程度上，可以将数据库分为永久型数据库和内存型数据库。</p><h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><p>​ 对于关系型数据库来说，数据表是以一个二维数组的形式来存储和管理数据的，它能够存储和管理数据并操作数据的逻辑结构。通常，一个数据表由行和列组成，一行数据能够表示一条完整的基础信息，所以行在关系型数据库中是组织数据的基本单位；列也被称为字段，它能够表示行的一个属性，同时，每一列都有相应的数据类型和数据长度的定义。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>​ 关系型数据库中的数据类型表示数据在数据库中的存储格式，其反映了数据在计算机中的存储格式。计算机根据不同的数据类型来组织和存储数据，并为不同数据类型的数据分配不同的存储空间。数据类型在大的分类上可以分为数值类型、日期和时间类型、字符串类型。在关系型数据库中，表中的每个字段都会被指定一种数据类型。例如，表1-1中，将商品编号、商品名称和商品类型定义为字符串类型，将商品价格定义为数值类型（定点数类型），将上架时间定义为日期和时间类型。</p><a id="more"></a><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>​ 数据库中内置了一些函数，能够很方便地对数据进行数学计算、字符串处理、加密/解密及聚合处理等。相应地，函数可以分为数学函数、字符串函数、日期和时间函数、流程处理函数、加密与解密函数、数据聚合函数、获取数据库信息函数以及数据库中的其他函数等</p><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>​ 在关系型数据库中，主键（Primary Key）又称为主码，能够唯一标识数据表中的一行记录。主键可以包含数据表中的一列或者多列，主键不能为空。同时，在同一个数据表中，主键列上不能有两行甚至多行相同的值，也就是说，在同一个数据表中，每行数据对应的主键列的值必须唯一。</p><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>​ 外键从本质上讲就是一个引用，它引用的是另外一张表中的一列或者多列数据，被引用的表中的列需要具备主键约束或者唯一性约束。也就是说，被引用的列在其对应的数据表中能够唯一标识一行数据。外键反映的是两个表之间的连接关系。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>​ 索引从本质上来讲是一种单独的数据库结构，它能够单独地存储在计算机的磁盘上，包含着对相关数据表中所有数据的引用指针。通过索引能够快速定位并查询出数据表中的一行或者多行数据，而不必进行全表扫描。在某种程度上，数据库的索引和书籍的目录有些类似。当查找书籍中的内容时，往往不会直接翻阅书籍的内容，这样查找起来相当烦琐；如果先根据书籍的目录定位到要查找的内容在书籍中的大概章节，然后再到相关的章节中去查找内容就比较简单了。索引使查询能够快速到达计算机中的某个位置去搜寻数据文件，而不必对所有的数据进行扫描。索引的建立，可以大大提高数据查询的效率</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>​ 视图从本质上来讲是数据库的一种虚表，它是由SELECT查询语句从一张表或者多张表中导出的一种虚表。不能向视图中插入、更新和删除数据，即视图不负责数据的实际存储。当通过视图修改数据时，实际上修改的是构成视图的基本表中的数据，当修改了构成视图的基本表中的数据时，视图中的数据也会随之改变。使用视图能够大大简化数据库中表与表之间复杂的关联查询。</p><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>​ 存储过程是一种SQL语句集，经过编译后存储在数据库中，通过指定存储过程的名称和参数信息来调用存储过程，使其完成特定的功能。在创建存储过程的时候，可以自定义变量来存储一些中间结果的数据，也可以在存储过程中定义一些执行逻辑和执行流程。存储过程经过一次编译后可以永久使用（只要不删除存储过程）。将一些复杂的查询逻辑封装在存储过程中重复使用，应用程序只需要调用存储过程的名称并传入相应的参数即可，大大简化了开发和数据查询的复杂度。另外，使用存储过程也可以防止用户直接访问数据表，只需要赋予用户对存储过程的访问权限即可。</p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>​ 触发器从本质上来讲是一种特殊的存储过程。触发器的执行不是由应用程序调用，也不是由手动执行的，而是由数据库中的事件执行的。当对某个表中的数据进行插入、更新和删除操作时，系统会自动执行相应的触发器。在某种程度上，触发器和钩子函数有些类似。应用程序在执行某项操作时，会自动调用相应的钩子函数，执行钩子函数的逻辑。而触发器是对数据表进行操作时自动执行的。当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>MySQL中最常用到的存储引擎是InnoDB和MyISAM</p><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><p>​ 在关系型数据库领域中，通常认为数据库系统涉及的软件主要由操作系统、数据库、数据库管理系统、以数据库管理系统为核心的应用开发工具和应用程序等几部分组成。</p><ul>    <li>操作系统（Operating System，OS）：直接运行于计算机硬件上的系统，为计算机中运行的各种软件提供基础环境支持。主流的操作系统包括Windows、UNIX/Linux和Mac OS等。</li>    <li>通常由某种或某几种高级编程语言编写，描述用户应用需求的应用程序、软件或某种管理系统。</li>    <li>数据库（DataBase，DB）：主要负责数据的存放，并在一定程度上保证数据的安全性、完整性和可靠性</li>    <li>数据库管理系统（DataBase Management System，DBMS）：主要用来对数据库进行管理，是数据库系统的核心组成部分。在实际工作中，人们往往不会直接面对数据库，而是通过数据库管理系统对数据库中的数据进行管理和维护。</li></ul><p>​ 数据库管理员（DataBase Administrator，DBA）：控制数据库整体结构的人，需要承担创建、管理、监控和维护整个数据库的责任，并保证数据库的安全、完整、高可用性与高可靠性。</p><h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><p>关系型数据库中专门提供了一种对数据库进行操作和查询的语言，叫作结构化查询语言，英文为Structured Query Language，简称SQL。</p><h3 id="SQL语言分类"><a href="#SQL语言分类" class="headerlink" title="SQL语言分类"></a>SQL语言分类</h3><ul>    <li>        <p>DDL（Data Definition Language，数据定义语言）：用于定义数据库、数据表和列，可以用来创建、删除、修改数据库和数据表的结构，包含CREATE、DROP和ALTER等语句。</p>    </li>    <li>        <p>DML（Data Manipulation Language，数据操作语言）：用于操作数据记录，可以对数据库中数据表的数据记录进行增加、删除和修改等操作，包含INSERT、DELETE和UPDATE等语句。</p>    </li>    <li>        <p>DCL（Data Control Language，数据控制语言）：用于定义数据库的访问权限和安全级别，主要包含GRANT、REVOKE、COMMIT和ROLLBACK等语句。</p>    </li>    <li>        <p>DQL（Data Query Language，数据查询语言）：用于查询数据表中的数据记录，主要包含SELECT语句。</p>    </li></ul><p>​ 关系型数据库提供了SQL语言，使应用程序开发人员与数据库管理和维护人员能够与数据库进行交互。但是在创建数据库和数据表之前，需要对数据库中的数据表进行设计，并能够正确设计出各数据表之间的关联关系。通常使用ER图（Entity Relationship Diagram），也就是实体-关系模型，来进行数据表的设计。ER图是用来描述现实世界的概念模型，在这个模型中有3个基本要素，分别为实体、属性和关系。</p><h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><p>​ 关系型数据库提供了SQL语言，使应用程序开发人员与数据库管理和维护人员能够与数据库进行交互。但是在创建数据库和数据表之前，需要对数据库中的数据表进行设计，并能够正确设计出各数据表之间的关联关系。通常使用ER图（Entity Relationship Diagram），也就是实体-关系模型，来进行数据表的设计。ER图是用来描述现实世界的概念模型，在这个模型中有3个基本要素，分别为实体、属性和关系。</p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>​ MySQL的三大范式能够规范开发人员对数据表的设计，使得开发人员能够设计出简洁、优雅的数据表结构。</p><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>​ 主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为<strong>不可再次拆分</strong>的<strong>最小数据单元</strong>。</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>指在第一范式的基础上，确保数据表中除了<strong>主键之外的每个字段</strong>都必须<strong>依赖主键</strong>。</p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>在第二范式的基础上，确保数据表中的每一列都和主键字段直接相关</p><blockquote>    <p>也就是说要求数据表中的所有非主键字段不能依赖于其他非主键字段</p></blockquote><h3 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h3><p>​ 当数据库中的数据量比较大且系统的UV和PV访问频次比较高，若完全按照MySQL的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。此时，可以通过在数据表中增加冗余字段减少关联来提高数据库的读性能。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>MySQL技术大全 — 冰河</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL数据库一些概念&quot;&gt;&lt;a href=&quot;#MySQL数据库一些概念&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据库一些概念&quot;&gt;&lt;/a&gt;MySQL数据库一些概念&lt;/h1&gt;
&lt;h2 id=&quot;数据库的定义&quot;&gt;&lt;a href=&quot;#数据库的定义&quot; class=&quot;headerlink&quot; title=&quot;数据库的定义&quot;&gt;&lt;/a&gt;数据库的定义&lt;/h2&gt;
&lt;p&gt;​ 数据库的定义在某种程度上，数据库代表着一种存储技术，并不局限于某种存储形式。一个简单的数据库可以将数据只存储在某台特定的计算机上，供某个特定的用户使用，而一个复杂的数据库可以将数据分散存储到多台计算机上，能够供成千上万的用户同时使用。从存储容量上来说，一个数据库的存储容量可以小到只能够存储几KB的数据，也可以大到存储TB甚至是PB级别的数据。&lt;/p&gt;
&lt;h3 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h3&gt;
&lt;p&gt;​ 数据库（DataBase，DB）从本质上讲就是一个文件系统，它能够将数据有组织地集合在一起，按照一定的规则长期存储到计算机的磁盘中，并且能够供多个用户共享和使用，同时，用户能够对数据库中的数据进行插入、删除、修改和查询操作。数据库将数据进行集中存储和管理，有效地分离了应用程序和业务数据，降低了应用程序和业务数据之间的耦合性，大大简化了数据的存储和管理工作。同时，数据库提供了对存储数据的统一控制功能。数据除了能够被存储在计算机的磁盘中，还能够被存储在计算机的内存中，所以在某种程度上，可以将数据库分为永久型数据库和内存型数据库。&lt;/p&gt;
&lt;h3 id=&quot;数据表&quot;&gt;&lt;a href=&quot;#数据表&quot; class=&quot;headerlink&quot; title=&quot;数据表&quot;&gt;&lt;/a&gt;数据表&lt;/h3&gt;
&lt;p&gt;​ 对于关系型数据库来说，数据表是以一个二维数组的形式来存储和管理数据的，它能够存储和管理数据并操作数据的逻辑结构。通常，一个数据表由行和列组成，一行数据能够表示一条完整的基础信息，所以行在关系型数据库中是组织数据的基本单位；列也被称为字段，它能够表示行的一个属性，同时，每一列都有相应的数据类型和数据长度的定义。&lt;/p&gt;
&lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h3&gt;
&lt;p&gt;​ 关系型数据库中的数据类型表示数据在数据库中的存储格式，其反映了数据在计算机中的存储格式。计算机根据不同的数据类型来组织和存储数据，并为不同数据类型的数据分配不同的存储空间。数据类型在大的分类上可以分为数值类型、日期和时间类型、字符串类型。在关系型数据库中，表中的每个字段都会被指定一种数据类型。例如，表1-1中，将商品编号、商品名称和商品类型定义为字符串类型，将商品价格定义为数值类型（定点数类型），将上架时间定义为日期和时间类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://paynewu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://paynewu.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://paynewu.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://paynewu.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>漫游密码学</title>
    <link href="https://paynewu.com/ckss9yca7004sxngoe79ibx9h.html"/>
    <id>https://paynewu.com/ckss9yca7004sxngoe79ibx9h.html</id>
    <published>2021-08-20T15:55:50.000Z</published>
    <updated>2021-08-24T03:03:30.261Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名优秀的新时代农民工，加密解密、编码算法自然逃不了。为了更安全、更隐蔽 数字签名，信息加密在开发过程中一定少不了，例如用户密码、关键消息等等，所以密码学至关重要。</p><p>作为爬虫工程师，逆向工程师见到目标的加密后的结果，而又无法有效的获取与定位到关键函数。那岂不是抓瞎，那么如果对于常见的加密、编码算法算法有足够的了解，那么是可以便捷很多，例如</p><ul>    <li>根据特征结果，直接Hook对应函数。通常有奇效</li>    <li>根据特征结果，与所知的参数进行尝试碰撞。也可大幅度减少分析时间</li></ul><p>等等，书到用时方恨少，知识与见识自然也是。</p><a id="more"></a><h2 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h2><p>​ 结合爬虫来看，对于密码学，加密与解密掌握自然的越精通越好，同时这又是一陡峭的过程。相较于与密码学相关知识结合爬虫来看并不一定要成为“密码学专家”，但确实拥有足够的<strong>了解</strong>将对于我们在逆向、防护方面有不错的帮助。就爬虫来说其中包含但不限于进制、摘要、非对称加密、对称加密等。</p><h2 id="0x02-加密与解密"><a href="#0x02-加密与解密" class="headerlink" title="0x02 加密与解密"></a>0x02 加密与解密</h2><p>加密，是以某种特殊的算法改变原有的信息数据</p><p>解密，加密的逆过程，常为加密等逆处理。</p><p>具体实现有编码算法，摘要算法、对称加密、非对称加密等。当然这之间可以一次或多次、一个或多个过程使用</p><h2 id="0x03-编码算法"><a href="#0x03-编码算法" class="headerlink" title="0x03 编码算法"></a>0x03 编码算法</h2><p>编码是信息从一种形式或格式转换为另一种形式的过程。根据映射关系实现转换。</p><p>常见的算法有Base16、Base32、Base64</p><h2 id="0x04-摘要算法"><a href="#0x04-摘要算法" class="headerlink" title="0x04 摘要算法"></a>0x04 摘要算法</h2><p>​ 消息摘要算法的主要特征是<strong>加密过程不需要密钥</strong>，并且经过加密的数据<strong>理论</strong>上无法被解密，目前可以被解密逆向的只有<a href="https://baike.baidu.com/item/CRC32/7460858" target="_blank" rel="noopener">CRC32</a>算法，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。消息摘要算法不存在密钥的管理与分发问题，较为适合于分布式网络上使用。由于其加密计算的工作量相当可观，这种算法通常只用于数据量有限的情况下的加密，</p><p>​ 消息摘要算法主要应用在“数字签名”领域，作为对明文的摘要算法。著名的摘要算法有MD5算法和SHA-1算法及其大量的变体。</p><blockquote>    <p>MD5:</p>    <blockquote>        <p>默认key:01234567890abdcdef</p>    </blockquote>    <p>变体：md2、md4、md5、hmac(带密码的md5)</p>    <p>种类：16位 32位 40位</p>    <p>SHA-1:</p>    <p>sha1 40位</p>    <p>sha256 64位</p>    <p>sha512 128位</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>消息摘要是把任意长度的输入揉和而产生长度固定的<a href="https://baike.baidu.com/item/伪随机" target="_blank" rel="noopener">伪随机</a>输入的算法。消息摘要的主要特点有：</p><ol>    <li>        <p>无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。例如应用MD5算法摘要的消息有128个比特位，用SHA-1算法摘要的消息最终有160比特位的输出，SHA-1的变体可以产生192比特位和256比特位的消息摘要。一般认为，摘要的最终输出越长，该摘要算法就越安全。</p>    </li>    <li>        <p>消息摘要看起来是“随机的”。这些比特看上去是胡乱的杂凑在一起的。可以用大量的输入来检验其输出是否相同，一般，不同的输入会有不同的输出，而且输出的摘要消息可以通过<a href="https://baike.baidu.com/item/随机性" target="_blank" rel="noopener">随机性</a>检验。但是，一个摘要并不是真正随机的，因为用相同的算法对相同的消息求两次摘要，其结果必然相同；而若是真正随机的，则无论如何都是无法重现的。因此消息摘要是“伪随机的”。</p>    </li>    <li>        <p>一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。这正是好的消息摘要算法所具有的性质：输入改变了，输出也就改变了；两条相似的消息的摘要确不相近，甚至会大相径庭。</p>    </li>    <li>        <p>消息摘要函数是无<a href="https://baike.baidu.com/item/陷门" target="_blank" rel="noopener">陷门</a>的单向函数，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息。当然，可以采用强力攻击的方法，即尝试每一个可能的信息，计算其摘要，看看是否与已有的摘要相同，如果这样做，最终肯定会恢复出摘要的消息。但实际上，要得到的信息可能是无穷个消息之一，所以这种强力攻击几乎是无效的。</p>    </li>    <li>        <p>好的摘要算法，没有人能从中找到“碰撞”，虽然“碰撞”是肯定存在的。即对于给定的一个摘要，不可能找到一条信息使其摘要正好是给定的。或者说，无法找到两条消息，使它们的摘要相同。</p>    </li></ol><h2 id="0x05加密"><a href="#0x05加密" class="headerlink" title="0x05加密"></a>0x05加密</h2><p>​ 加密一般分为对称式加密以及非对称式加密两类。采用的比较广泛的是对称式加密，主要特点是加密和解密使用同一个密钥。</p><p>​ 而非对称式加密在进行加密时则使用了两个密钥，加密和解密过程中分别使用不同的密钥，这两个密钥分别为“公钥”以及“私钥”，想要能正常完成加密解密过程，就必需配对使用，而在使用过程中，“公钥”是公开的，“私钥”则必须由发送人保密，同时只能由持有人所有。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>​ 需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。</p><p>​ 所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。</p><p>​ 因此加密的安全性不仅取决于<strong>加密算法本身，密钥管理的安全性更是重要</strong>。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。对称加密算法中常用的算法有：<a href="https://baike.baidu.com/item/DES" target="_blank" rel="noopener">DES</a>、<a href="https://baike.baidu.com/item/3DES" target="_blank" rel="noopener">3DES</a>、TDEA、<a href="https://baike.baidu.com/item/Blowfish" target="_blank" rel="noopener">Blowfish</a>、RC2、RC4、<a href="https://baike.baidu.com/item/RC5" target="_blank" rel="noopener">RC5</a>、<a href="https://baike.baidu.com/item/IDEA" target="_blank" rel="noopener">IDEA</a>、SKIPJACK等。</p><p>采用单钥密码的加密方法，同一个密钥可以同时用来加密和解密，这种加密方法称为对称加密，也称为单密钥加密。常用的单向加密算法：</p><p>1、DES（Data Encryption Standard）：<a href="https://baike.baidu.com/item/数据加密标准/1577169" target="_blank" rel="noopener">数据加密标准</a>，速度较快，适用于加密大量数据的场合；</p><p>2、3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；</p><p>3、AES（Advanced Encryption Standard）：<a href="https://baike.baidu.com/item/高级加密标准/468774" target="_blank" rel="noopener">高级加密标准</a>，是下一代的加密算法标准，速度快，安全级别高，支持128、192、256、512位密钥的加密；</p><p>4、Blowfish</p><p><strong>算法特征</strong></p><p>1、加密方和解密方使用同一个密钥；</p><p>2、加密解密的速度比较快，适合数据比较长时的使用；</p><p>3、密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密算法需要两个<a href="https://baike.baidu.com/item/密钥/101144" target="_blank" rel="noopener">密钥</a>来进行加密和解密，这两个密钥是<a href="https://baike.baidu.com/item/公开密钥/7453570" target="_blank" rel="noopener">公开密钥</a>（public key，简称公钥）和私有密钥（private key，简称私钥）。</p><ul>    <li><strong>RSA：</strong>RSA 是一种目前应用非常广泛、历史也比较悠久的非对称秘钥加密技术，在1977年被麻省理工学院的罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）三位科学家提出，由于难于破解，RSA 是目前应用最广泛的数字加密和签名技术，比如国内的支付宝就是通过RSA算法来进行签名验证。它的安全程度取决于秘钥的长度，目前主流可选秘钥长度为 1024位、2048位、4096位等，理论上秘钥越长越难于破解，按照维基百科上的说法，小于等于256位的秘钥，在一台个人电脑上花几个小时就能被破解，512位的秘钥和768位的秘钥也分别在1999年和2009年被成功破解，虽然目前还没有公开资料证实有人能够成功破解1024位的秘钥，但显然距离这个节点也并不遥远，所以目前业界推荐使用 2048 位或以上的秘钥，不过目前看 2048 位的秘钥已经足够安全了，支付宝的官方文档上推荐也是2048位，当然更长的秘钥更安全，但也意味着会产生更大的性能开销。</li>    <li><strong>DSA：</strong>既 Digital Signature Algorithm，数字签名算法，他是由美国国家标准与技术研究所（NIST）与1991年提出。和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</li>    <li><strong>ECDSA：</strong>Elliptic Curve Digital Signature Algorithm，椭圆曲线签名算法，是ECC（Elliptic curve cryptography，椭圆曲线密码学）和 DSA 的结合，椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的，相比于RSA算法，ECC 可以使用更小的秘钥，更高的效率，提供更高的安全保障，据称256位的ECC秘钥的安全性等同于3072位的RSA秘钥，和普通DSA相比，ECDSA在计算秘钥的过程中，部分因子使用了椭圆曲线算法。</li></ul><h3 id="加密小结"><a href="#加密小结" class="headerlink" title="加密小结"></a>加密小结</h3><p>对称加密只需要获取到公钥即可，进行解密</p><p><a href="https://baike.baidu.com/item/非对称加密算法" target="_blank" rel="noopener">非对称加密算法</a>需要两个<a href="https://baike.baidu.com/item/密钥" target="_blank" rel="noopener">密钥</a>：<a href="https://baike.baidu.com/item/公开密钥" target="_blank" rel="noopener">公开密钥</a>（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​ 简单来说加密与解密就阐述了密码学基本特征，非专业的了解。可大致了解编码、摘要、对称加密、非对称加密即可。后有兴趣可深入</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名优秀的新时代农民工，加密解密、编码算法自然逃不了。为了更安全、更隐蔽 数字签名，信息加密在开发过程中一定少不了，例如用户密码、关键消息等等，所以密码学至关重要。&lt;/p&gt;
&lt;p&gt;作为爬虫工程师，逆向工程师见到目标的加密后的结果，而又无法有效的获取与定位到关键函数。那岂不是抓瞎，那么如果对于常见的加密、编码算法算法有足够的了解，那么是可以便捷很多，例如&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;根据特征结果，直接Hook对应函数。通常有奇效&lt;/li&gt;
    &lt;li&gt;根据特征结果，与所知的参数进行尝试碰撞。也可大幅度减少分析时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等，书到用时方恨少，知识与见识自然也是。&lt;/p&gt;
    
    </summary>
    
    
      <category term="密码学" scheme="https://paynewu.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="加密与解密" scheme="https://paynewu.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
    
      <category term="密码学" scheme="https://paynewu.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="加密与解密" scheme="https://paynewu.com/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>调试与反调试</title>
    <link href="https://paynewu.com/ckss9ycan005wxngo8r4348dl.html"/>
    <id>https://paynewu.com/ckss9ycan005wxngo8r4348dl.html</id>
    <published>2021-08-18T15:57:41.000Z</published>
    <updated>2021-08-24T03:03:30.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调试与反调试"><a href="#调试与反调试" class="headerlink" title="调试与反调试"></a>调试与反调试</h1><p>相信各位如果从事爬虫开发、反爬虫开发、逆向工程师及相关岗位的开发，一定逃不开调试、反调试。那调试与反调是什么呢？以下为浏览器为例</p><p>调试：自然就是为了分析获取某关键加密参数，便对于目标网站的JS进行分析。</p><p>反调试：为了参数更加安全，更加难以破解。在合适处增加障碍增强调试难度</p><p>简单来说调试就是为了获取对应的加密参数，而反调试是为了不那么容易调试，增加调试难度。</p><p>反调试可以分为调试检测、调试陷阱，而反反调试是伪装，是绕过。</p><a id="more"></a><h2 id="反调试常见手段"><a href="#反调试常见手段" class="headerlink" title="反调试常见手段"></a>反调试常见手段</h2><p>反调试无论具体实现何种方法进行反调试 如无限debugger、内存爆破、投毒、删文件、脏话等。这都离不开一入口—— <strong>调试检测</strong>，反过来思考反调试是为了区分正常用户与开发者人员都一种方式，那么如果可以检测到开发者调试那么就可以对其进行相关的操作。</p><h3 id="调试检测"><a href="#调试检测" class="headerlink" title="调试检测"></a>调试检测</h3><p>调试检测的方案有很多，只要一经出发便可反制调试者。常用的检测方案如下</p><h4 id="控制台检测"><a href="#控制台检测" class="headerlink" title="控制台检测"></a>控制台检测</h4><h5 id="检测控制台检测的原理"><a href="#检测控制台检测的原理" class="headerlink" title="检测控制台检测的原理"></a>检测控制台检测的原理</h5><ul>    <li>        <p>隐式的调用元素id</p>    </li>    <li>        <p>隐式的调用RegExp的tostring方法</p>    </li>    <li>        <p>console，打开控制台console运行，否则不执行</p>    </li>    <li>        <p>浏览器窗口内外高度差</p>    </li></ul><blockquote>    <p>打开内置的chrome devtools 将造成高度差不一致</p></blockquote><h4 id="格式化检测"><a href="#格式化检测" class="headerlink" title="格式化检测"></a>格式化检测</h4><p>格式化检测也很实现原理也很简单，调用RegExp匹配相关部分代码</p><blockquote>    <p> 一般情况下目标服务器下发的JS为经过压缩。而调试者为了便于调试一般会对代码进行格式化，一旦检测点被格式化便可被RegExp检测</p></blockquote><h3 id="Hook检测"><a href="#Hook检测" class="headerlink" title="Hook检测"></a>Hook检测</h3><p>函数检测：采集调用 toString 方法对内容进行校验（伪造 toString 方法即可绕过）</p><p>对象检测：通过 <code>Object.defineProperty</code> 方法修改属性是不可更改的（可复写 debugger 即可）</p><h3 id="浏览器与浏览器指纹检测"><a href="#浏览器与浏览器指纹检测" class="headerlink" title="浏览器与浏览器指纹检测"></a>浏览器与浏览器指纹检测</h3><p>浏览器与浏览器指纹检测可检测的范围更广，更细致。具体请参考浏览器的相关api。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>调用时间差检测</p><blockquote>    <p>调试离不开debugger、断点，调用时间过长可视为被调试</p></blockquote><p>栈检测(在浏览器中可以使用caller获取调用栈)</p><blockquote>    <p>调试会打乱原有的调用栈</p></blockquote><p>tostings检测</p><blockquote>    <p>调试的时候难免遇到函数，习惯性的将鼠标放置在上面。hook Function toString可实现检测</p></blockquote><p>一切与“正常”执行相悖的都可作为检测点，也就是经常说的埋雷</p><h4 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h4><p><strong>蜜罐</strong> 也就是咱们所常听见的蜜罐。简单来说就是给予或引导调试者进入虚假的环境</p><p>蜜罐相对较于以上<strong>被动的检测</strong>拥有更多的灵活性，相对来说更加主动，更加激进。且蜜罐更一种实现思路，具体实现具体情况具体分析</p><h2 id="调试陷阱"><a href="#调试陷阱" class="headerlink" title="调试陷阱"></a>调试陷阱</h2><p>当检测到开发者正在调试，那么下一步就是抵御。实现思路一般有三种</p><ol>    <li>拦截：</li></ol><h3 id="预防调试"><a href="#预防调试" class="headerlink" title="预防调试"></a>预防调试</h3><p>主要目的为防止调试者继续或者进入下一步调试，常见的方式有引入僵尸代码、控制流等方式。</p><h3 id="阻断调试"><a href="#阻断调试" class="headerlink" title="阻断调试"></a>阻断调试</h3><p>较于拦截，阻断调试更加简单粗暴。常常伴随着无限循环。常见的实现方式有</p><figure class="highlight js">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>            </td>            <td class="code">                <pre><span class="line"># while</span><br><span class="line"><span class="keyword">while</span>(ture)</span><br><span class="line"><span class="keyword">while</span>(大于<span class="number">0</span>的数)</span><br><span class="line"><span class="keyword">while</span>(!![])</span><br><span class="line">  </span><br><span class="line"># for</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br></pre>            </td>        </tr>    </table></figure><p>递归</p><p>多函数死循环互调等实现内存爆破</p><h3 id="破坏调试"><a href="#破坏调试" class="headerlink" title="破坏调试"></a>破坏调试</h3><p>相对于阻断调试，会更加极端的手段，一方面对调试者信息进行采集、攻击调试者。例如删除文件、重置电脑、甚至释放病毒等</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节详细了解了检测与反调试，检测核心原理为区分代码运行环境是否一致、是否合理从而区分为正常运行还是调试运行。检测到后进行反调试，反调试一般主要体现在预防、阻断、破坏。而绕过的方案自然从检测入手，模拟环境、模拟运行时，从而进行绕过。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;调试与反调试&quot;&gt;&lt;a href=&quot;#调试与反调试&quot; class=&quot;headerlink&quot; title=&quot;调试与反调试&quot;&gt;&lt;/a&gt;调试与反调试&lt;/h1&gt;
&lt;p&gt;相信各位如果从事爬虫开发、反爬虫开发、逆向工程师及相关岗位的开发，一定逃不开调试、反调试。那调试与反调是什么呢？以下为浏览器为例&lt;/p&gt;
&lt;p&gt;调试：自然就是为了分析获取某关键加密参数，便对于目标网站的JS进行分析。&lt;/p&gt;
&lt;p&gt;反调试：为了参数更加安全，更加难以破解。在合适处增加障碍增强调试难度&lt;/p&gt;
&lt;p&gt;简单来说调试就是为了获取对应的加密参数，而反调试是为了不那么容易调试，增加调试难度。&lt;/p&gt;
&lt;p&gt;反调试可以分为调试检测、调试陷阱，而反反调试是伪装，是绕过。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="调试与反调试" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="爬虫" scheme="https://paynewu.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="调试与反调试" scheme="https://paynewu.com/tags/%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基于ssh-key实现服务器免密登陆</title>
    <link href="https://paynewu.com/ckss9yc9y0041xngo5cl61qmf.html"/>
    <id>https://paynewu.com/ckss9yc9y0041xngo5cl61qmf.html</id>
    <published>2021-08-05T14:39:59.000Z</published>
    <updated>2021-08-24T02:19:30.693Z</updated>
    
    <content type="html"><![CDATA[<p>远程连接Linux服务器，通常有两种方式，<br>第一种就是ssh直接远程连接， 第二种就是采用第三方的工具进行连接。<br>那么我本人是十分习惯以及喜欢终端（terminal）直接连接的。<br>一是因为快捷键更熟悉，另一方面是相对更安全。但采用ssh直接连接难免是有很多不便，<br>例如每次输入密码，例如每次输入远程ip地址。<br>密码我个人是喜欢设置成非常难以记忆的密码，保存在本地一个记事本或者文档里面，ip更不用说。记自然是不可能记的。那么如何实现ssh免密登陆以及ip的代号呢</p><a id="more"></a><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><figure class="highlight shell">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br></pre>            </td>            <td class="code">                <pre><span class="line">ssh-keygen -t rsa -C "your_email@youremailhost.com"</span><br></pre>            </td>        </tr>    </table></figure><h2 id="上传公钥到服务器"><a href="#上传公钥到服务器" class="headerlink" title="上传公钥到服务器"></a>上传公钥到服务器</h2><figure class="highlight bash">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br></pre>            </td>            <td class="code">                <pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@host</span><br></pre>            </td>        </tr>    </table></figure><h3 id="初次密码验证"><a href="#初次密码验证" class="headerlink" title="初次密码验证"></a>初次密码验证</h3><p>输入密码</p><p>下次直接使用ssh登陆即可实现免密登陆</p><figure class="highlight shell">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br></pre>            </td>            <td class="code">                <pre><span class="line">ssh user@host</span><br></pre>            </td>        </tr>    </table></figure><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>远程登录的ip一般来说都是没有规律的，也十分的难记。那么如何才能给他一个好记的名字来替代，但又好区分呢。方法也非常的简单。只需要将<code>/etc/host</code> 进行配置本地的域名解析映射即可。在<code>/etc/hots</code>下配置如下内容。</p><figure class="highlight bash">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br></pre>            </td>            <td class="code">                <pre><span class="line">172.168.146.95s2</span><br><span class="line">172.168.146.35s1</span><br></pre>            </td>        </tr>    </table></figure><p>下次ssh 连接<code>172.168.146.95</code> 的时候，直接使用<code>ssh root@s2</code>,即可达到<code>ssh root@172.168.146.95</code>一样的效果</p><p>·</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;远程连接Linux服务器，通常有两种方式，&lt;br&gt;第一种就是ssh直接远程连接， 第二种就是采用第三方的工具进行连接。&lt;br&gt;那么我本人是十分习惯以及喜欢终端（terminal）直接连接的。&lt;br&gt;一是因为快捷键更熟悉，另一方面是相对更安全。但采用ssh直接连接难免是有很多不便，&lt;br&gt;例如每次输入密码，例如每次输入远程ip地址。&lt;br&gt;密码我个人是喜欢设置成非常难以记忆的密码，保存在本地一个记事本或者文档里面，ip更不用说。记自然是不可能记的。那么如何实现ssh免密登陆以及ip的代号呢&lt;/p&gt;
    
    </summary>
    
    
      <category term="ssh" scheme="https://paynewu.com/categories/ssh/"/>
    
      <category term="Linux" scheme="https://paynewu.com/categories/ssh/Linux/"/>
    
      <category term="服务器" scheme="https://paynewu.com/categories/ssh/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="ssh" scheme="https://paynewu.com/tags/ssh/"/>
    
      <category term="Linux" scheme="https://paynewu.com/tags/Linux/"/>
    
      <category term="服务器" scheme="https://paynewu.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器指纹在反爬虫领域的应用</title>
    <link href="https://paynewu.com/ckss9yca7004qxngo3asq2hw1.html"/>
    <id>https://paynewu.com/ckss9yca7004qxngo3asq2hw1.html</id>
    <published>2021-07-14T08:07:22.000Z</published>
    <updated>2021-08-24T02:42:08.261Z</updated>
    
    <content type="html"><![CDATA[<p>在上文中较为详细的介绍了指纹、设备指纹的常规获取与获取指纹环境监测，本节将详细的了解一下</p><p>浏览器指纹在反爬虫领域的应用，Android分析暂且搁置（其实是我也并不精通，pc端比较熟悉一点）</p><a id="more"></a><p>本节详细的聊聊Web指纹，在学习前必须先给自己的几个问题？</p><h2 id="什么是web指纹？"><a href="#什么是web指纹？" class="headerlink" title="什么是web指纹？"></a>什么是web指纹？</h2><p>见上文</p><h3 id="Web指纹有何作用？"><a href="#Web指纹有何作用？" class="headerlink" title="Web指纹有何作用？"></a>Web指纹有何作用？</h3><p>Web指纹的作用有很多，例如区分环境、区分机器人与真实用户，保障正常运行，只要是web浏览器的特征均可以作为web指纹</p><h2 id="Web指纹有哪些？"><a href="#Web指纹有哪些？" class="headerlink" title="Web指纹有哪些？"></a>Web指纹有哪些？</h2><p>web指纹如下</p><p>全局：window、document</p><p>环境：navigator、screen、history</p><p>请求：XMLHttpRequest、fetch、worker、<code>.$ajax</code>(jquery)、SSL/TSL</p><p>Dom：canvas、dom的操作</p><p>存储：storage IndexedDB cookie</p><p>其他：Cache、WebGL、AndioContext、WebRTC</p><p>NodeJS</p><p>全局变量：global</p><p>导包：require「危险⚠️」</p><p>可被重写的全局</p><p>觉大多数的Web API</p><p>全部的DOM节点</p><p>Web API：<a href="https://developer.mozilla.org/zh-CN/docs/Web/api" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/api</a></p><p>NodeJs API：中文：<a href="http://nodejs.cn/api/" target="_blank" rel="noopener">http://nodejs.cn/api/</a> 官方： <a href="https://nodejs.org/api/" target="_blank" rel="noopener">https://nodejs.org/api/</a></p><p>异同：<a href="http://nodejs.cn/api/path.html" target="_blank" rel="noopener">http://nodejs.cn/api/path.html</a></p><p>无论做何操作均可视为区分正常用户与机器人，如果被检测出来，最简单的自然是拿不到数据，bt一点的蜜罐、甚至强制删除电脑内文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上文中较为详细的介绍了指纹、设备指纹的常规获取与获取指纹环境监测，本节将详细的了解一下&lt;/p&gt;
&lt;p&gt;浏览器指纹在反爬虫领域的应用，Android分析暂且搁置（其实是我也并不精通，pc端比较熟悉一点）&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/"/>
    
      <category term="JavaScript" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/JavaScript/"/>
    
      <category term="技巧" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/JavaScript/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="JS" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/JavaScript/%E6%8A%80%E5%B7%A7/JS/"/>
    
    
      <category term="爬虫" scheme="https://paynewu.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/tags/Crawler/"/>
    
      <category term="Web Spider" scheme="https://paynewu.com/tags/Web-Spider/"/>
    
      <category term="数据采集" scheme="https://paynewu.com/tags/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"/>
    
      <category term="JS" scheme="https://paynewu.com/tags/JS/"/>
    
      <category term="Chrome" scheme="https://paynewu.com/tags/Chrome/"/>
    
      <category term="JavaScript" scheme="https://paynewu.com/tags/JavaScript/"/>
    
      <category term="技巧" scheme="https://paynewu.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>认识设备指纹</title>
    <link href="https://paynewu.com/ckss9ycam005uxngobf0w07at.html"/>
    <id>https://paynewu.com/ckss9ycam005uxngobf0w07at.html</id>
    <published>2021-07-12T14:09:17.000Z</published>
    <updated>2021-08-24T02:19:30.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识指纹"><a href="#认识指纹" class="headerlink" title="认识指纹"></a>认识指纹</h2><h3 id="什么是指纹"><a href="#什么是指纹" class="headerlink" title="什么是指纹"></a>什么是指纹</h3><p>设备指纹、浏览器指纹也是同理根据软硬件信息，设备版本、设备操作系统等差异性从而生成唯一的设备指纹。</p><blockquote>    <p>人的手有手指、手掌握纹，通过凹凸规则、分布状态的差异造就了<strong>相对</strong>其独一无二的特征。</p></blockquote><a id="more"></a><h3 id="指纹是怎么产生"><a href="#指纹是怎么产生" class="headerlink" title="指纹是怎么产生"></a>指纹是怎么产生</h3><p>手机的操作系统、浏览器厂商为了方便用户与开发者获取用户的设备信息预留了一些API供程序使用，用户和开发者可以通过这些API获取客户端相关的软硬件信息</p><p>这些信息因人而异通过部分信息来产生<strong>相对差异</strong>的信息来生成生成相对独立的设备ID。</p><blockquote>    <p>简单理解就是软件信息（部分或全部）、硬件信息（部分或全部）+ 指纹生成算法=生成指纹</p></blockquote><p>辨识度的信息可以是系统信息、软件信息、地理位置、时区、语言等等，所给予的信息决定了浏览器指纹的准确性。</p><h3 id="设备指纹究竟是如何区分的“唯一”"><a href="#设备指纹究竟是如何区分的“唯一”" class="headerlink" title="设备指纹究竟是如何区分的“唯一”"></a>设备指纹究竟是如何区分的“唯一”</h3><p>在一般情况下单一维度的差异性并不能形成标识设备的稳定特性，但可以经过收集大量的隐形特征通过数据分析、建模等方式等组合使用，可以更加精准的区分唯一</p><blockquote>    <p>例如：我们常见的双胞胎，它们长相相似、声音神似但根据以上两种特征无法有效的区分，但却可以根据更深层的习惯、喜好，甚至是某种条件反射的特殊因子，还是可以较为有效的降低“指纹”的碰撞率</p></blockquote><h3 id="什么信息是不能包含作为设备指纹？"><a href="#什么信息是不能包含作为设备指纹？" class="headerlink" title="什么信息是不能包含作为设备指纹？"></a>什么信息是不能包含作为设备指纹？</h3><p>根据国家法律要求，以下信息不能被作为指纹的因素</p><ul>    <li>手机号</li>    <li>通话记录</li>    <li>短信</li>    <li>通讯录</li>    <li>身份证号</li>    <li>等</li></ul><blockquote>    <p>虽然这些信息有非常强的一致性，可以非常有效的提高设备指纹的准确性</p>    <p>但是涉猎个人隐私的数据都是不可触碰的信息。网上绝非法外之地</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>设备指纹相同，很大概率上是同一设备或用户；但设备指纹不同时，不一定不是同一设备或用户</p><h2 id="设备指纹实现原理与检测"><a href="#设备指纹实现原理与检测" class="headerlink" title="设备指纹实现原理与检测"></a>设备指纹实现原理与检测</h2><p>采集设备指纹需要满足两大特征：较为稳定的环境、篡改监测</p><h3 id="手机之Android设备指纹"><a href="#手机之Android设备指纹" class="headerlink" title="手机之Android设备指纹"></a>手机之Android设备指纹</h3><p>设备的Id需要兼具稳定性、唯一性，但Android系统的开源和碎片化导致API函数实现不尽相同。下表是Android系统比较稳定的设备参数</p><div class="table-container">    <table>        <thead>            <tr>                <th style="text-align:center">采集项</th>                <th style="text-align:center">中文含义</th>                <th style="text-align:center">特征</th>            </tr>        </thead>        <tbody>            <tr>                <td style="text-align:center">Android ID</td>                <td style="text-align:center">设备首次启动时自动随机生成的设备ID</td>                <td style="text-align:center">1.不需要授权，相同信号的手机小概率碰撞<br />2.恢复出厂设置将被重置</td>            </tr>            <tr>                <td style="text-align:center">IMEI/MEID</td>                <td style="text-align:center">设备码<br />移动、联通获取IMEI<br />电信获取MEID</td>                <td style="text-align:center">1.唯一性质较好，还是存在小概率碰撞<br />2.需要READ_PHONE_STATE权限<br />3.未含有卡槽的设备无法获取</td>            </tr>            <tr>                <td style="text-align:center">IMSI</td>                <td style="text-align:center">手机SIM卡识别</td>                <td style="text-align:center">1.需要READ_PHONE_STATE权限<br />2.更换手机卡会改变</td>            </tr>            <tr>                <td style="text-align:center">WI-FI MAC</td>                <td style="text-align:center">网卡MAC地址</td>                <td style="text-align:center">1.当未连接WI-FI时，有概率获取失败<br />2.个别只读存储器恢复出厂设置会被重置</td>            </tr>            <tr>                <td style="text-align:center">Bluetooth MAC</td>                <td style="text-align:center">蓝牙MAC地址</td>                <td style="text-align:center">高版本Android系统无法获取（约8.0以上）</td>            </tr>            <tr>                <td style="text-align:center">Serial</td>                <td style="text-align:center">设备串号</td>                <td style="text-align:center">同类型号的手机碰撞概率高</td>            </tr>            <tr>                <td style="text-align:center">Fingerprint</td>                <td style="text-align:center">设备多个硬件编号统称</td>                <td style="text-align:center">同类型号的手机碰撞概率高</td>            </tr>            <tr>                <td style="text-align:center">Storage</td>                <td style="text-align:center">内存、磁盘空间</td>                <td style="text-align:center">同类型号的手机碰撞概率高</td>            </tr>            <tr>                <td style="text-align:center">Adverting ID</td>                <td style="text-align:center">Google Play广告ID</td>                <td style="text-align:center">仅限于Google服务用户使用</td>            </tr>        </tbody>    </table></div><p>Android设备所有采集的项都是Android公开的API，采集项被大面积篡改的情况下不能保持设备ID不变，通常有效的方式就是<strong>检测和监控运行环境</strong>，针对Android设备指纹检测可归纳为</p><ol>    <li>通过安装安装包检测安装环境</li>    <li>通过特定的特征识别root环境</li>    <li>通过多种方案采集同一字段信息检测环境是否<strong>异常</strong></li>    <li>通过通用的修改方式识别（例如中间人攻击、注入、Hook、重放攻击等），从而达到检测环境的效果</li>    <li>通过特定特征识别（例如Xpose、Frida、模拟器等）检测</li></ol><h3 id="手机之IOS设备指纹"><a href="#手机之IOS设备指纹" class="headerlink" title="手机之IOS设备指纹"></a>手机之IOS设备指纹</h3><p>IOS相对开源的Android系统权限更加严格，且手机型号、系统版本较与Android更单一。由于权限等影响IOS能够获取的设备参数较少。如下表列举了较稳定的IOS设备参数</p><div class="table-container">    <table>        <thead>            <tr>                <th style="text-align:center">采集项</th>                <th style="text-align:center">中文含义</th>                <th style="text-align:center">特征</th>            </tr>        </thead>        <tbody>            <tr>                <td style="text-align:center">DeviceName</td>                <td style="text-align:center">设备名称</td>                <td style="text-align:center">1.用户可以自行修改，默认值存在很大的碰撞<br />2.自定义值有较强的特征</td>            </tr>            <tr>                <td style="text-align:center">WI-FI MAC</td>                <td style="text-align:center">网卡MAC地址</td>                <td style="text-align:center">唯一性好，高版本手机不能稳定性采集</td>            </tr>            <tr>                <td style="text-align:center">Boot time</td>                <td style="text-align:center">系统开机时间（μs微秒）</td>                <td style="text-align:center">1.存在少量碰撞，重启会发生改变<br />2.采集多次可能会发生变化</td>            </tr>            <tr>                <td style="text-align:center">Storage</td>                <td style="text-align:center">内存、磁盘空间</td>                <td style="text-align:center">同类型号的手机碰撞概率高</td>            </tr>            <tr>                <td style="text-align:center">IDFV</td>                <td style="text-align:center">厂商标识符</td>                <td style="text-align:center">1.不能跨合作方<br />2.删除本合作方APP后重新安装发生改变</td>            </tr>            <tr>                <td style="text-align:center">IDFA</td>                <td style="text-align:center">广告标识符</td>                <td style="text-align:center">1.需要广告权限<br />2。用户可以限制广告追踪</td>            </tr>        </tbody>    </table></div><p>IOS大部分篡改都是基于Hook进行改机，以及模拟器。</p><blockquote>    <p>IOS模拟器其本质为在X86_64架构上运行iPhone自带的模拟器，同时APP需要页数适配才能被安装</p></blockquote><p>IOS采集指纹检测可分为如下</p><ul>    <li>通过通用的Hook原理进行识别</li>    <li>通过特定的工具特征识别</li>    <li>寻找特定空间存储设备标识进行识别</li>    <li>对抗备份、抹机，进行识别</li></ul><h3 id="Web设备指纹"><a href="#Web设备指纹" class="headerlink" title="Web设备指纹"></a>Web设备指纹</h3><p>Web设备指纹（浏览器指纹）是指用户硬件、软件信息综合计算产生标识</p><h4 id="Web指纹特点"><a href="#Web指纹特点" class="headerlink" title="Web指纹特点"></a>Web指纹特点</h4><p>通过Javascript采集信息生成对应设备ID，与传统的Cookie技术相比较，Web设备指纹更加稳定</p><p>稳定浏览器版本采集参数，如下表所示</p><div class="table-container">    <table>        <thead>            <tr>                <th style="text-align:center">采集项</th>                <th style="text-align:center">中文含义</th>                <th style="text-align:center">特征</th>            </tr>        </thead>        <tbody>            <tr>                <td style="text-align:center">UserAgent</td>                <td style="text-align:center">浏览器客户端标识</td>                <td style="text-align:center">可以任意伪装与修改</td>            </tr>            <tr>                <td style="text-align:center">Gpu</td>                <td style="text-align:center">设备GPU特征</td>                <td style="text-align:center">1.碰撞率高<br />2.可跨浏览器</td>            </tr>            <tr>                <td style="text-align:center">Canvas</td>                <td style="text-align:center">2D指纹</td>                <td style="text-align:center">唯一性好（不同浏览器的指纹不同）</td>            </tr>            <tr>                <td style="text-align:center">Webgl</td>                <td style="text-align:center">3D指纹</td>                <td style="text-align:center">1.碰撞率高<br />2.可跨浏览器</td>            </tr>            <tr>                <td style="text-align:center">Plugin List</td>                <td style="text-align:center">浏览器自带插件列表</td>                <td style="text-align:center">当用户安装特殊插件，相同浏览器碰撞率高</td>            </tr>            <tr>                <td style="text-align:center">FontList</td>                <td style="text-align:center">字体列表</td>                <td style="text-align:center">当用户安装特殊字体，相同浏览器碰撞率高</td>            </tr>            <tr>                <td style="text-align:center">IP</td>                <td style="text-align:center">内网IP/外网IP</td>                <td style="text-align:center">1.切换网络会改变<br />2.内网采集局限性大</td>            </tr>            <tr>                <td style="text-align:center">TCP</td>                <td style="text-align:center">网络协议</td>                <td style="text-align:center">1. 不同操作系统协议差异大<br />2.不易被修改<br />3.用户无感知<br />4.碰撞率极高</td>            </tr>            <tr>                <td style="text-align:center">Navigator</td>                <td style="text-align:center">有关浏览器的信息</td>                <td style="text-align:center">相同系统、相同版本碰撞率极大</td>            </tr>        </tbody>    </table></div><p>Web指纹采集检测可如下</p><ol>    <li>识别浏览器异常环境</li>    <li>特征检测（原型链）检测Hook</li>    <li>特定特征识别JS是否调试与检测（控制台、debugger等）</li>    <li>特殊方式存储浏览器设备标识（如localStorage）</li></ol><p>Web指纹采集检测原理可如下</p><p><strong>无头浏览器识别</strong></p><ul>    <li>UA识别：检测/Headless Chrome/.test(Navigator.userAgent)</li>    <li>Webdriver检测: Webdriver是否在 navigator</li>    <li>selenium检测：检测<code>window.seleium</code></li>    <li>PhantomJS\nightmare-JS 检测</li>    <li>等</li></ul><p><strong>隐身模式识别</strong></p><p>Chrome：在隐身模式下，FileSystem API禁止，使用报异常</p><p>Firefox：在隐身模式下，IndexedDB执行Open报异常</p><p>Safari：在隐身模式下，localStorage对象存在，但运行setItem方法报异常</p><p><strong>控制台检测</strong><br>设备<br>隐式调用元素Id</p><p>隐式调用Regexp等toString</p><p><strong>Hook检测</strong></p><p>自定义Hook检测：在定义函数时将函数整体作为参数生成Hash值在执行该函数时校验Hash值</p><p>函数检测：采集调用toString方法对内容进行校验（伪造toString方法即可绕过）</p><p>对象检测：通过<code>Object.defineProperty</code>方法修改属性是不可更改的（可复写debugger即可）</p><p>其他检测：</p><p>SSL/TLS检测（产品：akamai）</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>浏览器指纹在线检测：<a href="http://f.vision/" target="_blank" rel="noopener">http://f.vision/</a></p><p>修改浏览器指纹：<a href="https://www.cnblogs.com/68xi/p/13353140.html" target="_blank" rel="noopener">https://www.cnblogs.com/68xi/p/13353140.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;认识指纹&quot;&gt;&lt;a href=&quot;#认识指纹&quot; class=&quot;headerlink&quot; title=&quot;认识指纹&quot;&gt;&lt;/a&gt;认识指纹&lt;/h2&gt;
&lt;h3 id=&quot;什么是指纹&quot;&gt;&lt;a href=&quot;#什么是指纹&quot; class=&quot;headerlink&quot; title=&quot;什么是指纹&quot;&gt;&lt;/a&gt;什么是指纹&lt;/h3&gt;
&lt;p&gt;设备指纹、浏览器指纹也是同理根据软硬件信息，设备版本、设备操作系统等差异性从而生成唯一的设备指纹。&lt;/p&gt;
&lt;blockquote&gt;
    &lt;p&gt;人的手有手指、手掌握纹，通过凹凸规则、分布状态的差异造就了&lt;strong&gt;相对&lt;/strong&gt;其独一无二的特征。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="调试" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Hook" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/%E8%B0%83%E8%AF%95/Hook/"/>
    
    
      <category term="爬虫" scheme="https://paynewu.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/tags/Crawler/"/>
    
      <category term="JS" scheme="https://paynewu.com/tags/JS/"/>
    
      <category term="浏览器" scheme="https://paynewu.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="调试" scheme="https://paynewu.com/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Hook" scheme="https://paynewu.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>常见安全产品(pc)</title>
    <link href="https://paynewu.com/ckss9yca4004jxngo0ytyfss4.html"/>
    <id>https://paynewu.com/ckss9yca4004jxngo0ytyfss4.html</id>
    <published>2021-07-11T13:36:28.000Z</published>
    <updated>2021-08-24T17:47:37.880Z</updated>
    
    <content type="html"><![CDATA[<p>在做爬虫的时候，很多时候都会遇到较成熟成体系的安全产品。更好的”认识”它，对于解决有至关重要的帮助。以下一起来了解一下网站常见防护产品及特征</p><blockquote>    <p>声明：本节不涉猎任何实际的产品破解，仅介绍其特征与辨别方式或思路。以下仅根据个人现所了解暂划分为一线、二线等。</p></blockquote><h3 id="一线"><a href="#一线" class="headerlink" title="一线"></a>一线</h3><blockquote>    <p>学习的对象，自研产品。安全系数高，分析较困难</p></blockquote><p>ali、akamai、jd、pdd、google(含无感验证码)、各大银行支付接口</p><a id="more"></a><h4 id="ali滑块"><a href="#ali滑块" class="headerlink" title="ali滑块"></a>ali滑块</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs4rk7k7tgj31p60qkq5m.jpg" alt=""></p><p>控制台中有g.alicdn.com字样，其中/后为版本号</p><h4 id="akamai"><a href="#akamai" class="headerlink" title="akamai"></a>akamai</h4><blockquote>    <p>主要在tls指纹进行相关加密</p></blockquote><h4 id="jd"><a href="#jd" class="headerlink" title="jd"></a>jd</h4><blockquote>    <p>自写的虚拟机</p></blockquote><h4 id="pdd"><a href="#pdd" class="headerlink" title="pdd"></a>pdd</h4><blockquote>    <p>Web pack 打包 + 风控</p></blockquote><h4 id="google-含无感验证码"><a href="#google-含无感验证码" class="headerlink" title="google(含无感验证码)"></a>google(含无感验证码)</h4><p>5s 盾 + 谷歌验证码</p><p>绕过方案与线索</p><ul>    <li>5秒盾 <a href="https://mp.weixin.qq.com/s/zwmatF3yTgSyS0gz8sinaA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zwmatF3yTgSyS0gz8sinaA</a></li>    <li>谷歌验证码打码绕过方案<a href="https://cuiqingcai.com/30026.html" target="_blank" rel="noopener">https://cuiqingcai.com/30026.html</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtseloz24yj61d60naaca02.jpg" alt="image-20210825014317964"></p><h3 id="二线"><a href="#二线" class="headerlink" title="二线"></a>二线</h3><blockquote>    <p>可敬的对象</p></blockquote><p>加密与代码保护：瑞数信息（瑞数）、创宇超防（加速乐）、</p><p>验证码：极验、数美、五秒盾、易盾、顶象</p><h4 id="加密与代码保护"><a href="#加密与代码保护" class="headerlink" title="加密与代码保护"></a>加密与代码保护</h4><h5 id="瑞数信息（瑞数）"><a href="#瑞数信息（瑞数）" class="headerlink" title="瑞数信息（瑞数）"></a>瑞数信息（瑞数）</h5><ol>    <li>未带cookie访问首先是一段神奇的页面，如下图所示</li></ol><p><img src="/Users/stringle-004/Library/Application Support/typora-user-images/image-20210711183607468.png" alt="image-20210711183607468"></p><p>特征：</p><p>1.</p><p>一长段的：content。有点类似于ob的大数组</p><p>script标签中带有 r=“m”的字样</p><p>执行加密函数1，函数名为 <code>_$xx(xxx)</code></p><p>执行加密函数2（实际加密处）</p><ol>    <li>无比恶心的乱码</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsd76unofcj30sp02qt8m.jpg" alt="ddddd"></p><ol>    <li>        <p>动态js</p>    </li>    <li>        <p>版本号</p>        <p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsd8b8qfa3j305y00i0si.jpg" alt=""></p>        <p><img src="/Users/stringle-004/Library/Application Support/typora-user-images/image-20210711192226256.png" alt="image-20210711192226256"></p>    </li></ol><p>首数字开头的编号，编号常见的有4、5、6代</p><h5 id="创宇超防（加速乐）"><a href="#创宇超防（加速乐）" class="headerlink" title="创宇超防（加速乐）"></a>创宇超防（加速乐）</h5><ol>    <li>未带cookies访问，先是一段神奇的JS，设置cookie。如下图所示</li></ol><p><img src="/Users/stringle-004/Library/Application Support/typora-user-images/image-20210711183150521.png" alt="image-20210711183150521"></p><p>实际内容如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsd6qt4brnj311b02qjrj.jpg" alt=""></p><ol>    <li>        <p>魔改ob</p>        <p>用于cookies拼接</p>        <p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsd6wykikcj31lf0u0n36.jpg" alt=""></p>    </li></ol><h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><h5 id="极验"><a href="#极验" class="headerlink" title="极验"></a>极验</h5><p>geetest(极验)官网：<a href="https://www.geetest.com/" target="_blank" rel="noopener">https://www.geetest.com/</a></p><p>demo：<a href="https://www.geetest.com/demo/" target="_blank" rel="noopener">https://www.geetest.com/demo/</a></p><p><img src="/Users/stringle-004/Library/Application Support/typora-user-images/image-20210711195920957.png" alt="image-20210711195920957"></p><!----------><h5 id="数美"><a href="#数美" class="headerlink" title="数美"></a>数美</h5><p>官网：<a href="https://www.ishumei.com/" target="_blank" rel="noopener">https://www.ishumei.com/</a></p><p>体验：<a href="https://www.ishumei.com/trial/captcha.html" target="_blank" rel="noopener">https://www.ishumei.com/trial/captcha.html</a></p><p><img src="/Users/stringle-004/Library/Application Support/typora-user-images/image-20210711195358760.png" alt="image-20210711195358760"></p><h5 id="网易易盾"><a href="#网易易盾" class="headerlink" title="网易易盾"></a>网易易盾</h5><p>官网：<a href="https://dun.163.com/" target="_blank" rel="noopener">https://dun.163.com/</a></p><p>Demo：<a href="https://dun.163.com/trial/space-inference" target="_blank" rel="noopener">https://dun.163.com/trial/space-inference</a></p><p><img src="/Users/stringle-004/Library/Application Support/typora-user-images/image-20210711200120467.png" alt="image-20210711200120467"></p><h5 id="Vaptcha"><a href="#Vaptcha" class="headerlink" title="Vaptcha"></a>Vaptcha</h5><p><a href="https://www.vaptcha.com/" target="_blank" rel="noopener">https://www.vaptcha.com/</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsd8xpb30oj30vc0g1afq.jpg" alt=""></p><h5 id="顶象"><a href="#顶象" class="headerlink" title="顶象"></a>顶象</h5><p><img src="/Users/stringle-004/Library/Application Support/typora-user-images/image-20210711195702599.png" alt="image-20210711195702599"></p><h3 id="三线"><a href="#三线" class="headerlink" title="三线"></a>三线</h3><blockquote>    <p>主要来源于开源框架</p></blockquote><p>Ob混淆系（obfuscator、sojson、Jsaham）、Jsfuck、JJEncode、AAEncode、eval等、</p><p>obfuscator: <a href="https://obfuscator.io/" target="_blank" rel="noopener">https://obfuscator.io/</a></p><p>sojson：<a href="https://www.sojson.com/jsjiemi.html" target="_blank" rel="noopener">https://www.sojson.com/jsjiemi.html</a></p><p>Jsaham：<a href="http://www.jshaman.com/#section2" target="_blank" rel="noopener">http://www.jshaman.com/#section2</a></p><p>jstuck:<a href="http://www.jsfuck.com/" target="_blank" rel="noopener">http://www.jsfuck.com/</a> GitHub:<a href="https://github.com/aemkei/jsfuck" target="_blank" rel="noopener">https://github.com/aemkei/jsfuck</a></p><p>JJEncode:<a href="http://www.atoolbox.net/Tool.php?Id=704" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=704</a></p><p>JJEncode:<a href="http://www.atoolbox.net/Tool.php?Id=703" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=703</a></p><p>Eval:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval</a>;</p><p>​ 分析：eval换为console.log()(前提：console.log未改写)</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="ob系列"><a href="#ob系列" class="headerlink" title="ob系列"></a>ob系列</h5><p>特点</p><ol>    <li>大数组</li>    <li>数据移位（常见regex内存检测，建议不format绕过或remove regex）</li>    <li>解密函数（常见regex内存检测，建议不format绕过或remove regex）</li>    <li>定时器setInterval() 、setTimeout() + 无限debugger （可能含有）</li>    <li><strong>业务代码 + 控制流平坦化：（ob强度90%取决于此代码强度、这里是加密前的逻辑）</strong></li>    <li>控制流平坦化 + 无限debugger + 僵尸代码注入（一般不含有业务逻辑）</li></ol><p>Example:</p><ol>    <li>找到实际处（ob）</li>    <li>找前三段（数组、数组移位、解密函数），剪切出去</li>    <li>格式化控制流平坦化、实际逻辑。放回前剪切出去的内容</li>    <li>定位加密函数</li></ol><h5 id="Jsfuck、JJEncode、AAEncode"><a href="#Jsfuck、JJEncode、AAEncode" class="headerlink" title="Jsfuck、JJEncode、AAEncode"></a>Jsfuck、JJEncode、AAEncode</h5><p>配合eval类型防护：</p><blockquote>    <ol>        <li>直接放控制台console执行(报非unsafe错误)；点击错位堆栈直接完成脱壳</li>    </ol></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsdbgkbq35j30ix0bjwet.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsdbfu2amkj31ae02maa0.jpg" alt=""></p><p><img src="/Users/stringle-004/Library/Application Support/typora-user-images/image-20210711211026971.png" alt="image-20210711211026971"></p><blockquote>    <p>2.控制台不报错，构建强制报错。删除一些代码（为了不干扰原本代码，建议删除括号或加无意义代码）</p>    <p>3。控制台报unsafe错误，自写html文件运行。参考以上</p></blockquote><p>混淆部分数字：</p><h3 id="四线"><a href="#四线" class="headerlink" title="四线"></a>四线</h3><blockquote>    <p>工程化工具、各种加密函数魔改、辅助作用</p></blockquote><p>webpack、vue、react、angular</p><p>webpack：<a href="https://webpack.docschina.org/" target="_blank" rel="noopener">https://webpack.docschina.org/</a></p><p>关键点：加载器（也叫分发器）</p><p>经典绕过方案：点位插桩</p><p>扣取思路：找到加载器、扣出加载器构建自己的加载器（网站与关键参数（函数））、补环境</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做爬虫的时候，很多时候都会遇到较成熟成体系的安全产品。更好的”认识”它，对于解决有至关重要的帮助。以下一起来了解一下网站常见防护产品及特征&lt;/p&gt;
&lt;blockquote&gt;
    &lt;p&gt;声明：本节不涉猎任何实际的产品破解，仅介绍其特征与辨别方式或思路。以下仅根据个人现所了解暂划分为一线、二线等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一线&quot;&gt;&lt;a href=&quot;#一线&quot; class=&quot;headerlink&quot; title=&quot;一线&quot;&gt;&lt;/a&gt;一线&lt;/h3&gt;
&lt;blockquote&gt;
    &lt;p&gt;学习的对象，自研产品。安全系数高，分析较困难&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ali、akamai、jd、pdd、google(含无感验证码)、各大银行支付接口&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/"/>
    
      <category term="JavaScript" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/JavaScript/"/>
    
      <category term="技巧" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/JavaScript/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="JS" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/JavaScript/%E6%8A%80%E5%B7%A7/JS/"/>
    
    
      <category term="爬虫" scheme="https://paynewu.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/tags/Crawler/"/>
    
      <category term="Web Spider" scheme="https://paynewu.com/tags/Web-Spider/"/>
    
      <category term="数据采集" scheme="https://paynewu.com/tags/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"/>
    
      <category term="JS" scheme="https://paynewu.com/tags/JS/"/>
    
      <category term="Chrome" scheme="https://paynewu.com/tags/Chrome/"/>
    
      <category term="JavaScript" scheme="https://paynewu.com/tags/JavaScript/"/>
    
      <category term="技巧" scheme="https://paynewu.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>网页调试干扰总结</title>
    <link href="https://paynewu.com/ckss9ycaj005pxngoemv5fik0.html"/>
    <id>https://paynewu.com/ckss9ycaj005pxngoemv5fik0.html</id>
    <published>2021-07-03T15:42:42.000Z</published>
    <updated>2021-08-24T02:42:08.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网页反调试总结"><a href="#网页反调试总结" class="headerlink" title="网页反调试总结"></a>网页反调试总结</h2><p>网站除了对代码进行加密进行保护，还时常携带了反调试手段。例如无限debugger；内存爆破，控制台检测。</p><p>相关无限debugger进行反调试阻挠请参考上文，不在此过多赘述。本节主要学习内存爆破原理与绕过思想、控制台检测原理与绕过，</p><a id="more"></a><h3 id="内存爆破"><a href="#内存爆破" class="headerlink" title="内存爆破"></a>内存爆破</h3><p>通俗来理解是通过“特殊手段”不断开辟新内存，造成内存存储不足，从而使程序或电脑宕机。内存爆破并没有一种具体的实现方式，如果实现了内存爆破的效果都可以称之为内存爆破。</p><blockquote>    <p>当我们在编程的时候，每当声明一个变量、初始化一个函数。都会在开辟一块内存。</p></blockquote><h4 id="内存爆破实现的流程"><a href="#内存爆破实现的流程" class="headerlink" title="内存爆破实现的流程"></a>内存爆破实现的流程</h4><p>检测环境</p><p>实现内存爆破</p><blockquote>    <p>此处的环境为泛指，当与正常用户访问相悖或有差异均可以以此为为“入口”，开始内存爆破</p></blockquote><h4 id="内存爆破常见入口点"><a href="#内存爆破常见入口点" class="headerlink" title="内存爆破常见入口点"></a>内存爆破常见入口点</h4><p>hook检测</p><blockquote>    <p>监听函数情况，当函数被hook，且未完善的伪装hook时。</p></blockquote><p>代码格式化检测</p><blockquote>    <p>正常情况下，代码被压缩成一行或几行。但在运行时不符。</p></blockquote><p>浏览器指纹检测</p><blockquote>    <p>当运行环境与所规定的环境不同时</p></blockquote><p>控制台检测</p><blockquote>    <p>监听控制台，当控制台被打开时。</p></blockquote><h4 id="内存爆破特征"><a href="#内存爆破特征" class="headerlink" title="内存爆破特征"></a>内存爆破特征</h4><ol>    <li>检测环境</li>    <li>与预期环境不符合，死循环；符合，正常退出</li></ol><figure class="highlight js">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="comment">// 内存爆破示例代码</span></span><br><span class="line">h = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检测</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"正常执行"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 进入陷阱</span></span><br><span class="line">        <span class="keyword">while</span> (!![]) &#123;</span><br><span class="line">            c = <span class="keyword">new</span> <span class="built_in">Array</span>().push(<span class="keyword">void</span> <span class="number">0</span>);;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"内存爆破， 危！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>            </td>        </tr>    </table></figure><p>在浏览器中执行<strong>内存爆破示例代码</strong>， 如下图所示</p><p>符合预期，正常情况下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs44y083cmj310o0pm75b.jpg" alt=""></p><p>不符合，触发内存爆破</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs450veqckj31lk0u0n1b.jpg" alt=""></p><p>过了一小会，你就会发现，崩溃了！！！</p><h4 id="内存爆破总结"><a href="#内存爆破总结" class="headerlink" title="内存爆破总结"></a>内存爆破总结</h4><p>内存爆破，更像一种陷阱。如果触发了该陷阱，有了这个“入口”，便开始内存爆破。</p><h4 id="如何绕过内存爆破？"><a href="#如何绕过内存爆破？" class="headerlink" title="如何绕过内存爆破？"></a>如何绕过内存爆破？</h4><p>由于内存爆破的“入口”并不一致，所以内存爆破也并没有通用的解决方案。可提供的思路为“阻断”进入内存爆破，便为绕过。</p><p>例如</p><p>hook检测，伪装hook原型链即可</p><p>代码格式化检测，在检测处进行处理即可</p><p>浏览器指纹检测，伪装浏览器指纹，保持一致即可</p><p>控制台检测，处理检测代码即可。</p><h2 id="控制台检测原理与绕过"><a href="#控制台检测原理与绕过" class="headerlink" title="控制台检测原理与绕过"></a>控制台检测原理与绕过</h2><p>不知你也是否和我一样遇见过这种情况，当打开控制台时。浏览器就直接崩溃，获取其他情况。</p><h4 id="控制台检测原理"><a href="#控制台检测原理" class="headerlink" title="控制台检测原理"></a>控制台检测原理</h4><p>检测原理为与“正常”浏览网站有差异</p><p>当打开控制台的时候,会触发如下两种情况</p><ol>    <li>debugger可执行了</li>    <li>div会自动获取id属性</li></ol><p>第一种也就是我们常说的debugger调试干扰，</p><blockquote>    <p>只要控制台打开，debugger便会执行。一直相关联的无限deugger便会随之而来（如果有）</p></blockquote><p>第二种，当浏览器有使用<code>document.createElement</code>创建标签时，会创建该标签。<strong>当控制台打开会自动获取其id属性</strong>。</p><p>如果在绑定他，在对他进行内存爆破等操作。那么就。。。</p><h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><p>滞空该标签即可</p><p>pass</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网页反调试总结&quot;&gt;&lt;a href=&quot;#网页反调试总结&quot; class=&quot;headerlink&quot; title=&quot;网页反调试总结&quot;&gt;&lt;/a&gt;网页反调试总结&lt;/h2&gt;
&lt;p&gt;网站除了对代码进行加密进行保护，还时常携带了反调试手段。例如无限debugger；内存爆破，控制台检测。&lt;/p&gt;
&lt;p&gt;相关无限debugger进行反调试阻挠请参考上文，不在此过多赘述。本节主要学习内存爆破原理与绕过思想、控制台检测原理与绕过，&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="调试" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Hook" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/%E8%B0%83%E8%AF%95/Hook/"/>
    
    
      <category term="爬虫" scheme="https://paynewu.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/tags/Crawler/"/>
    
      <category term="JS" scheme="https://paynewu.com/tags/JS/"/>
    
      <category term="浏览器" scheme="https://paynewu.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="调试" scheme="https://paynewu.com/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Hook" scheme="https://paynewu.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>网站防护总结之pc</title>
    <link href="https://paynewu.com/ckss9ycag005fxngo2vu448sv.html"/>
    <id>https://paynewu.com/ckss9ycag005fxngo2vu448sv.html</id>
    <published>2021-07-02T09:25:18.000Z</published>
    <updated>2021-08-24T02:42:08.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要数据防护？"><a href="#为什么需要数据防护？" class="headerlink" title="为什么需要数据防护？"></a>为什么需要数据防护？</h2><p>当今如今大数据时代，数据重要不言而喻，网页和 App 作为主流的数据载体，如果其数据没有任何的保护措施，在爬虫工程师解决了一些基本的反爬如User-Agent、cookies、验证码等的防护措施之后，那么数据依旧可被轻易的获取。</p><h2 id="数据防护主要体现在何处？"><a href="#数据防护主要体现在何处？" class="headerlink" title="数据防护主要体现在何处？"></a>数据防护主要体现在何处？</h2><a id="more"></a><p>数据防护可简略的划分为请求防护、数据内容防护、验证码</p><h3 id="请求防护"><a href="#请求防护" class="headerlink" title="请求防护"></a>请求防护</h3><ul>    <li>User-Agent</li>    <li>Cookie</li>    <li>签名验证</li>    <li>握手验证</li>    <li>协议</li>    <li>        <p>。。。</p>        <h3 id="数据内容防护"><a href="#数据内容防护" class="headerlink" title="数据内容防护"></a>数据内容防护</h3>    </li>    <li>        <p>CSS字体偏移</p>    </li>    <li>SVG字体映射</li>    <li>图片数据</li>    <li>。。。<h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3>    </li></ul><p>个人总结为以下几种类型，具体体现不在过多赘述。（注，几者之间无明显的分割标准，在此以侧重点划分）</p><ul>    <li>识别点选或输入型</li>    <li>滑轨、滑块型</li>    <li>短信或语音验证型<h2 id="思"><a href="#思" class="headerlink" title="思"></a>思</h2>    </li></ul><p>实现这一切的一切，这些究竟是基于什么实现的？这一切绝可能是凭空出现！！！</p><p>其实无论是ajax，User-Agent、还是Cookie等等大部分都是基于Javascript实现。而且由于JavaScript在客户端中为完全透明，用户可以随意的查看与调试，这无异于代码裸奔。虽然以上的反爬虫虽然不错，但如果仔细分析的，这难度也仅是“工作量”的问题。</p><h2 id="Javascript防护分类"><a href="#Javascript防护分类" class="headerlink" title="Javascript防护分类"></a>Javascript防护分类</h2><p>完全透明的JS代码，虽然可以有效的防止。但这还不够，其根本原因还是JavaScript为明文。而这一切的一切都是“治标不治本”，虽然可以但还不够。也正因为对JavaScript的各种防护，所以才让这些加密“动”起来，无法轻易的分析。对JavaScript“加密”可分为如下几种大类</p><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><p>JavaScript 压缩是指去除 JavaScript 代码中的不必要的空格、换行等内容，或者将一些可能公用的代码进行处理实现共享，最后输出的结果都被压缩为几行内容，代码可读性变差，提高分析难度同时也能提高网站加载速度。</p><p>整体来说，压缩技术只能在很小的程度上起到防护作用，要想真正提高防护效果还得依靠混淆与加密技术。</p><h3 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h3><p>代码混淆是增加分析难度而牺牲部分性能的一种方案，此方案大部分是体现在通过逻辑转换换等方式将代码转化为难以分析的代码。难以分析是混淆的目的，等价转换是需要确保混淆前后的代码需不影响运行的功能。对于混淆可以又分为如下四种：布局混淆、数据混淆、控制混淆、预防混淆</p><h4 id="布局混淆"><a href="#布局混淆" class="headerlink" title="布局混淆"></a>布局混淆</h4><p>布局混淆指在源代码中删除原有无用代码，处理常量名、变量名函数名等标识符，增加对于代码的阅读与分析。</p><p>无用代码：注释、调试信息、缩进、换行、无用函数与数据等</p><p>处理常量名、变量名函数名等标识符：</p><ul>    <li>标识重命名：将原有代码重命名为无具体意义的字符，例如 将name 重命名为a</li></ul><p>注意点：</p><ul>    <li>作用域内标识符碰撞情况</li></ul><p><strong>小结</strong></p><p>布局混淆并不会影响执行的过程、内存开销，甚至代码体积反而减少了。</p><h4 id="数据混淆"><a href="#数据混淆" class="headerlink" title="数据混淆"></a>数据混淆</h4><p>JS拥有常见的7种数据类型，number、string、boolean、unfined、null、Object</p><p><strong>数字混淆</strong></p><p>数据混淆有常见：进制转换、数字分治、其他</p><ul>    <li>进制转换</li></ul><p>将十进制转化为二进制、八进制、十六进制等，从而达到“混淆”的目的</p><ul>    <li><strong>数学分治</strong></li></ul><p>简而言之就是将数拆开，例如 2 = 1 + 1，再辅以数学公式等</p><ul>    <li>        <p>其他</p>        <p>重新赋值等</p>    </li></ul><p><strong>字符串混淆</strong></p><p>字符串混淆常见的有编码转换、加密。常见的有hash、base64、md5等</p><p><strong>boolean</strong></p><p>我们都知道Boolean值为True、False。根据对boolean的处理，变成难以显示阅读的代码。例如![] = False, !![] = True.</p><p><strong>控制混淆</strong></p><p>控制混淆是指对程序的控制流进行转换变化，常见的方式有插入僵尸代码、控制流平坦化</p><p>插入僵尸代码：插入僵尸代码即插入无用的代码，增强调试难度</p><p>控制流平坦化：控制流平坦化,将原本的的执行流程平坦化。具体可自行搜索</p><p><strong>预防混淆</strong></p><p>主要体现在 提高反混淆的难度或检测现有混淆器中的漏洞设计</p><h3 id="代码混淆总结"><a href="#代码混淆总结" class="headerlink" title="代码混淆总结"></a>代码混淆总结</h3><p>万变不离其宗，无论是代码压缩、代码混淆都离不开一个宗旨，在不改变原有的<strong>结果</strong>情况下对代码（这里指JS）进行处理。处理的方式包含但不限于，等值转换、运算分割。</p><h2 id="设备指纹防护"><a href="#设备指纹防护" class="headerlink" title="设备指纹防护"></a>设备指纹防护</h2><p>设备指纹通过收集客户端设备的特征信息对用户与“机器人”进行甄别。web设备指纹主要包含：</p><p>浏览器端环境检测</p><p>浏览器设别标识</p><p>特征识别Hook</p><p>JS特征识别</p><p>做爬虫的朋友一定使用过NodeJs，这个工具。也时常借用与Nodejs来模拟JS，但Nodejs的api和指纹浏览器有不一样。如果服务端获取到客户端，那么就可以对指纹不一致的机器人，进行防范。</p><p>正如你我所知的那般，知道的越多，不知道的越多。</p><h2 id="推荐阅读与了解"><a href="#推荐阅读与了解" class="headerlink" title="推荐阅读与了解"></a>推荐阅读与了解</h2><p>风控要略：互联网业务反欺诈之路</p><p>Jsfuck（github）：<a href="https://github.com/aemkei/jsfuck" target="_blank" rel="noopener">https://github.com/aemkei/jsfuck</a></p><p>基于控制混淆和布局混淆的代码混淆系统-王岩（论文）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么需要数据防护？&quot;&gt;&lt;a href=&quot;#为什么需要数据防护？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要数据防护？&quot;&gt;&lt;/a&gt;为什么需要数据防护？&lt;/h2&gt;
&lt;p&gt;当今如今大数据时代，数据重要不言而喻，网页和 App 作为主流的数据载体，如果其数据没有任何的保护措施，在爬虫工程师解决了一些基本的反爬如User-Agent、cookies、验证码等的防护措施之后，那么数据依旧可被轻易的获取。&lt;/p&gt;
&lt;h2 id=&quot;数据防护主要体现在何处？&quot;&gt;&lt;a href=&quot;#数据防护主要体现在何处？&quot; class=&quot;headerlink&quot; title=&quot;数据防护主要体现在何处？&quot;&gt;&lt;/a&gt;数据防护主要体现在何处？&lt;/h2&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="调试" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Hook" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/%E8%B0%83%E8%AF%95/Hook/"/>
    
    
      <category term="爬虫" scheme="https://paynewu.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/tags/Crawler/"/>
    
      <category term="JS" scheme="https://paynewu.com/tags/JS/"/>
    
      <category term="浏览器" scheme="https://paynewu.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="调试" scheme="https://paynewu.com/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Hook" scheme="https://paynewu.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>网页调试之JSHook</title>
    <link href="https://paynewu.com/ckss9ycah005hxngo0r4ggqei.html"/>
    <id>https://paynewu.com/ckss9ycah005hxngo0r4ggqei.html</id>
    <published>2021-06-12T14:25:29.000Z</published>
    <updated>2021-08-24T02:42:08.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网页调试之JSHook"><a href="#网页调试之JSHook" class="headerlink" title="网页调试之JSHook"></a>网页调试之JSHook</h2><h3 id="什么是Hook？"><a href="#什么是Hook？" class="headerlink" title="什么是Hook？"></a>什么是Hook？</h3><p>Hook 又叫作钩子技术，它就是在程序运行的过程中，对其中的某个方法进行重写，在原有的方法前后自定义的代码。相当于在系统没有调用该函数之前，钩子程序就先捕获该消息，可以先得到控制权，这时钩子函数便可以加工处理（改变）该函数的执行行为。执行函数后释放控制权限，继续运行原有逻辑。</p><a id="more"></a><h3 id="Hook执行流程图"><a href="#Hook执行流程图" class="headerlink" title="Hook执行流程图"></a>Hook执行流程图</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxgrt9q3sj30kv0j3wej.jpg" alt=""></p><h3 id="Hook思路"><a href="#Hook思路" class="headerlink" title="Hook思路"></a>Hook思路</h3><ol>    <li>寻找hook点</li>    <li>hook</li>    <li>伪装hooker</li>    <li>调试(堆栈)</li></ol><h3 id="Hook公式"><a href="#Hook公式" class="headerlink" title="Hook公式"></a>Hook公式</h3><figure class="highlight javascript">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="comment">// 函数hooker</span></span><br><span class="line"><span class="keyword">var</span> func_copy = func</span><br><span class="line">func = <span class="function"><span class="keyword">function</span>(<span class="params">argument</span>)</span>&#123;</span><br><span class="line"><span class="comment">// hooker</span></span><br><span class="line">  <span class="keyword">return</span> func.apply(obj,argument)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性hooker</span></span><br><span class="line"><span class="keyword">var</span> attr_copy = obj.attr</span><br><span class="line"><span class="built_in">Object</span>.defineProprety(obj, <span class="string">'attr'</span> &#123;</span><br><span class="line">  <span class="keyword">get</span>:function() &#123;</span><br><span class="line"><span class="comment">// your code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span>:function() &#123;</span><br><span class="line"><span class="comment">// your code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>            </td>        </tr>    </table></figure><h3 id="Hook实例"><a href="#Hook实例" class="headerlink" title="Hook实例"></a>Hook实例</h3><figure class="highlight js">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="comment">// hook btoa</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    alert(<span class="string">'Start Hooking ...'</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hook</span>(<span class="params">obj, attr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> func = obj[attr]</span><br><span class="line">        obj[attr] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'hooked'</span>, obj, attr, <span class="built_in">arguments</span>)</span><br><span class="line">            <span class="keyword">var</span> ret = func.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">            <span class="keyword">debugger</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'result'</span>, ret)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Disguise the prototype</span></span><br><span class="line">        attr.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"function btoa() &#123; [native code] &#125;"</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        attr.length = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hook(<span class="built_in">window</span>, <span class="string">'btoa'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook eval</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Start Hooking ...'</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Hooker</span>(<span class="params">obj, attr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> func = obj[attr]</span><br><span class="line">        obj[attr] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'hooked'</span>, obj, attr, <span class="built_in">arguments</span>);</span><br><span class="line">            <span class="keyword">var</span> result = func.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">            <span class="keyword">debugger</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'result'</span>, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Disguise the prototype</span></span><br><span class="line">        attr.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"function eval() &#123; [native code] &#125;"</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        attr.length = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Hooker(<span class="built_in">window</span>, <span class="string">'eval'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hook document.cookie</span></span><br></pre>            </td>        </tr>    </table></figure><h3 id="Hook-优与劣"><a href="#Hook-优与劣" class="headerlink" title="Hook 优与劣"></a>Hook 优与劣</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>    <li>快速定位函数，方便调试</li>    <li>注入，不影响原本逻辑</li></ol><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h4><ol>    <li>新手难以有效的hook</li>    <li>反hook往往需要分析与绕过（类似于包装类、浏览器指纹、内部类等）</li></ol><h4 id="Hook伪装"><a href="#Hook伪装" class="headerlink" title="Hook伪装"></a>Hook伪装</h4><blockquote>    <p>函数hook伪装</p></blockquote><figure class="highlight js">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="comment">// Disguise the prototype</span></span><br><span class="line">attr.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"function btoa() &#123; [native code] &#125;"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">attr.length = <span class="number">1</span>;</span><br></pre>            </td>        </tr>    </table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgwa9ysgcj31d00bcjv6.jpg" alt=""></p><h3 id="更底层的Hook-原型链Hook"><a href="#更底层的Hook-原型链Hook" class="headerlink" title="更底层的Hook(原型链Hook)"></a>更底层的Hook(原型链Hook)</h3><p>在以上，我们对于函数进行了hook的总结，但若需要hook更加底层的函数该如何？</p><p>如果想要hook 例如 字符串的split方法,match方法。该如何？使用以上的方法将无法有效的实现hook。</p><p>示例：</p><figure class="highlight js">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>            </td>            <td class="code">                <pre><span class="line">func = <span class="string">"需Hook处"</span></span><br><span class="line"></span><br><span class="line"># 常规hook思路(错误示例)</span><br><span class="line"><span class="number">1.</span>保存改写函数</span><br><span class="line"><span class="number">2.</span>重写hook函数</span><br><span class="line"><span class="number">3.</span>下<span class="keyword">debugger</span>或其他调试逻辑</span><br><span class="line"></span><br><span class="line">split = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre>            </td>        </tr>    </table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs2rfrdgp1j307p04dq2t.jpg" alt=""></p><p>可正常操作</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs2rhklerfj30830493yd.jpg" alt=""></p><p>无法实现对于split的hook，常规方案无法实现hook。</p><blockquote>    <p>思考：为什么无法hook split -&gt; 没有hook到split</p>    <p>为什么无法hook split？ -&gt; 没有hook到split</p>    <p>Split 的“原函数”在哪里？-&gt; 原型链 -&gt; String的方法</p></blockquote><p>所以如果需要hook，就需要从原型链处进行入手,发现其实as.split 与 String.prototype 是同一个东西</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gs2rrew34wj307a029a9v.jpg" alt=""></p><p>那么我们直接对于进行如下操作,在控制台（console）中输入</p><figure class="highlight js">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="keyword">as</span> = “hook mark”;</span><br><span class="line"></span><br><span class="line"># rewrite</span><br><span class="line"><span class="built_in">String</span>.prototype.split = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'val'</span>);</span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre>            </td>        </tr>    </table></figure><p>此时调用split函数，就会发现已经完成对split的hook</p><p><img src="/Users/stringle-004/Library/Application Support/typora-user-images/image-20210702181800770.png" alt="image-20210702181800770"></p><p>随之而来的又是一个新问题，hook的为只要字符串调用split方法就都会被debugger到。显然并不适合在实践中进行调试。如下给出完整的hook split的代码</p><figure class="highlight js">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="comment">// create split cache from proto</span></span><br><span class="line"><span class="built_in">String</span>.prototype.split_cache = <span class="built_in">String</span>.prototype.split</span><br><span class="line"><span class="built_in">String</span>.prototype.split = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Gets the variable of the current scope</span></span><br><span class="line">    str = <span class="keyword">this</span>.String();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Arguments:'</span>, val)</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="keyword">return</span> str.split_cache(val);</span><br><span class="line">&#125;</span><br></pre>            </td>        </tr>    </table></figure><blockquote>    <p>如果感觉不明白为什么需要这样写的，或许需要复习一下js 原型链相关知识</p></blockquote><h3 id="Hook失败原因归纳"><a href="#Hook失败原因归纳" class="headerlink" title="Hook失败原因归纳"></a>Hook失败原因归纳</h3><p>Hook函数有时也会出现hook失败或者hook失效的情况，个人总结如下：</p><ol>    <li>函数hook一般情况下Hook不会失败，若失败一定是对于该函数的<code>__proto__</code>进行检测，此时只需要对<code>__proto__</code>,进行伪装即可</li>    <li>当目标网站的所有逻辑都采用了<code>Object.defineProperty</code>时，属性Hook就会失效</li>    <li>当Hook的函数为“内部”函数时，需要特殊的手段进行处理。例如将该函数加入到内存中。（当未加载页面，也会造成Hook失效）</li></ol><h3 id="常用Hook逻辑"><a href="#常用Hook逻辑" class="headerlink" title="常用Hook逻辑"></a>常用Hook逻辑</h3><p>具体示例请参考：<a href="https://github.com/Payne-Wu/JsHookScript" target="_blank" rel="noopener">https://github.com/Payne-Wu/JsHookScript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网页调试之JSHook&quot;&gt;&lt;a href=&quot;#网页调试之JSHook&quot; class=&quot;headerlink&quot; title=&quot;网页调试之JSHook&quot;&gt;&lt;/a&gt;网页调试之JSHook&lt;/h2&gt;
&lt;h3 id=&quot;什么是Hook？&quot;&gt;&lt;a href=&quot;#什么是Hook？&quot; class=&quot;headerlink&quot; title=&quot;什么是Hook？&quot;&gt;&lt;/a&gt;什么是Hook？&lt;/h3&gt;
&lt;p&gt;Hook 又叫作钩子技术，它就是在程序运行的过程中，对其中的某个方法进行重写，在原有的方法前后自定义的代码。相当于在系统没有调用该函数之前，钩子程序就先捕获该消息，可以先得到控制权，这时钩子函数便可以加工处理（改变）该函数的执行行为。执行函数后释放控制权限，继续运行原有逻辑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="调试" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Hook" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/%E8%B0%83%E8%AF%95/Hook/"/>
    
    
      <category term="爬虫" scheme="https://paynewu.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/tags/Crawler/"/>
    
      <category term="JS" scheme="https://paynewu.com/tags/JS/"/>
    
      <category term="浏览器" scheme="https://paynewu.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="调试" scheme="https://paynewu.com/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Hook" scheme="https://paynewu.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>网页调试之debugger原理与绕过</title>
    <link href="https://paynewu.com/ckss9ycai005mxngo015x5e4h.html"/>
    <id>https://paynewu.com/ckss9ycai005mxngo015x5e4h.html</id>
    <published>2021-06-09T01:02:14.000Z</published>
    <updated>2021-08-24T02:42:08.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网页调试之debugger原理与绕过"><a href="#网页调试之debugger原理与绕过" class="headerlink" title="网页调试之debugger原理与绕过"></a>网页调试之debugger原理与绕过</h2><p>debugger 语句用于停止执行 JavaScript(以下简称JS)，并调用 (如果可用) 调试函数。</p><p>使用 debugger 语句类似于在代码中设置断点。</p><a id="more"></a><p><strong>注意：</strong> <strong>如果调试工具不可用，则调试语句将无法工作。</strong></p><h3 id="实现debugger功能"><a href="#实现debugger功能" class="headerlink" title="实现debugger功能"></a>实现debugger功能</h3><h4 id="直接使用书写debugger"><a href="#直接使用书写debugger" class="headerlink" title="直接使用书写debugger"></a>直接使用书写debugger</h4><figure class="highlight js">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>            </td>            <td class="code">                <pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"IE=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Example DEBUGGER&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">debugger</span>;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre>            </td>        </tr>    </table></figure><p>当我们使用浏览器打开Devtools即执行debugger；如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grbr2fe8bsj30wp05hq32.jpg" alt=""></p><h4 id="eval配合debugger"><a href="#eval配合debugger" class="headerlink" title="eval配合debugger"></a>eval配合debugger</h4><blockquote>    <p>eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。</p>    <p>如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。</p></blockquote><figure class="highlight plain">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>            </td>            <td class="code">                <pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Example DEBUGGER&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var a &#x3D; 1;</span><br><span class="line">        eval(&quot;var 1 &#x3D; 1;debugger&quot;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre>            </td>        </tr>    </table></figure><blockquote>    <p>当使用eval执行时，将会在虚拟机中执行，也就是说非同一作用域。</p>    <p>同时也由于<code>将字符串当作表达式来执行</code>，那么里面常常伴随着代码混淆</p></blockquote><h4 id="函数内执行debugger"><a href="#函数内执行debugger" class="headerlink" title="函数内执行debugger"></a>函数内执行debugger</h4><figure class="highlight javascript">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>            </td>            <td class="code">                <pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"IE=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Example DEBUGGER&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> data = <span class="built_in">Date</span>();</span><br><span class="line">            alert(data);</span><br><span class="line">            <span class="keyword">debugger</span>;</span><br><span class="line">        &#125;())</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre>            </td>        </tr>    </table></figure><p>因为以上三种体现形式，在debugger上所设计的方案十分多。例如常见的无限制debugger、配合settimeout延迟debugger、代码混淆+debugger等等。</p><p>设置debugger的原理去对抗反爬，其核心原理就是<code>如果调试工具可用，则调试语句将执行</code>.也就是经常一打开就跳出debugger。</p><blockquote>    <p>无限debugger，其实是一种泛指的概念，无限泛指多，而非真的无限</p>    <p>其基于debugger之上，在此加入多次执行debugger的语句从而实现“无限debugger”。“反正只要chrome Devtools不开debugger便不会执行”.（经过调试是这样的，如果不准确请自行完善哦）</p></blockquote><h3 id="debugger绕过原理"><a href="#debugger绕过原理" class="headerlink" title="debugger绕过原理"></a>debugger绕过原理</h3><p>debugger的绕过也很简单，我个人总结共有两种大的方向。它们分别是替换、掠过。其原理都是不让debugger执行。个人并不推荐新手使用替换法中的方法</p><ul>    <li>替换法<ul>            <li>JS注入</li>            <li>重写(Hook)</li>        </ul>    </li>    <li>掠过法<ul>            <li>Never pause here</li>            <li>条件断点</li>        </ul>    </li></ul><h4 id="JS注入"><a href="#JS注入" class="headerlink" title="JS注入"></a>JS注入</h4><p>实现js注入的方式有很多，例如chrome Devtools的overrides、fiddler autoresponse、 mitmproxy、Charles的map local等等。若有兴趣自行搜索其使用方式</p><h4 id="Never-pause-here"><a href="#Never-pause-here" class="headerlink" title="Never pause here"></a>Never pause here</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grfmlz26gtj30gk04hmxb.jpg" alt=""></p><p>找到debugger前面的行号，鼠标右键点击该行号，点击Never pause here。便会跳过此断点</p><h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grfmohbkekj30b7029wee.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1grfmqch8l2j30gz02j3yd.jpg" alt=""></p><p>找到debugger前面的行号，鼠标右键点击该行号，点击 Add conditional breakpoint，直接写false。回车即可</p><h4 id="Deactivate-breakpoints"><a href="#Deactivate-breakpoints" class="headerlink" title="Deactivate breakpoints"></a>Deactivate breakpoints</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gro1s7b06wj30a401m0si.jpg" alt=""></p><p>打开这个图标如下图所示（高亮为打开）</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gro1somwu8j301w01aa9t.jpg" alt=""></p><p>当遇见breakpoints时会执行一次断点，鼠标单击如下图标</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gro1svh0onj301m01c3y9.jpg" alt=""></p><p>即可直接跳过breakpoints。</p><blockquote>    <p>小技巧：Deactivate breakpoints可以配合xhr、dom、Script等断点使用，便于调试</p></blockquote><h4 id="Hook绕过"><a href="#Hook绕过" class="headerlink" title="Hook绕过"></a>Hook绕过</h4><figure class="highlight js">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"debugger"</span>);</span><br><span class="line">&#125;</span><br></pre>            </td>        </tr>    </table></figure><figure class="highlight plain">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>            </td>            <td class="code">                <pre><span class="line">(function() &#123;</span><br><span class="line">    var eval_cache &#x3D; eval;</span><br><span class="line">    eval &#x3D; function(obj) &#123;</span><br><span class="line">        if (obj.indexof(&#39;debugger&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">            eval_cache(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br></pre>            </td>        </tr>    </table></figure><blockquote>    <p>此方法有局限性，若在此函数(在这里指函数a)若没有借用相关函数（eval），那么就无法使用此方法绕过</p></blockquote><h4 id="函数滞空法"><a href="#函数滞空法" class="headerlink" title="函数滞空法"></a>函数滞空法</h4><p>当遇见断点时，回退一次堆栈。将对应函数滞空即可,例如遇见如下的debugger</p><figure class="highlight js">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"debugger"</span>);</span><br><span class="line">&#125;</span><br></pre>            </td>        </tr>    </table></figure><p>直接在控制台输入如下内容即可。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gro22wyydqj30zk06qt8s.jpg" alt=""></p><blockquote>    <p>此方法有局限性，若在此函数中还参杂了关键代码，将可能无法访问或调试等</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Debugger绕过其实并不难，但在调试中仅仅是一道“开胃菜”，本节总结了debugger的实现方式，以及触发机制。当然也总结了几种我已知的所有绕过方案。</p><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>如何hook“变量”debugger？如果可以实现那么就可以实现反调试的debugger“通杀”，当然目前我也有在探究此方案。在加到hook函数中，那么调试便可以近似于一步到位。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网页调试之debugger原理与绕过&quot;&gt;&lt;a href=&quot;#网页调试之debugger原理与绕过&quot; class=&quot;headerlink&quot; title=&quot;网页调试之debugger原理与绕过&quot;&gt;&lt;/a&gt;网页调试之debugger原理与绕过&lt;/h2&gt;
&lt;p&gt;debugger 语句用于停止执行 JavaScript(以下简称JS)，并调用 (如果可用) 调试函数。&lt;/p&gt;
&lt;p&gt;使用 debugger 语句类似于在代码中设置断点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="调试" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="爬虫" scheme="https://paynewu.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/tags/Crawler/"/>
    
      <category term="JS" scheme="https://paynewu.com/tags/JS/"/>
    
      <category term="浏览器" scheme="https://paynewu.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="调试" scheme="https://paynewu.com/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis:在集合中复制键</title>
    <link href="https://paynewu.com/ckss9yc9c002fxngo0huhbvmk.html"/>
    <id>https://paynewu.com/ckss9yc9c002fxngo0huhbvmk.html</id>
    <published>2021-06-03T11:06:09.000Z</published>
    <updated>2021-08-24T02:42:08.267Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述: 由于某种原因，我必须需要将某个集合的键（Key）复制一份副本。并移动到目标库</strong></p><p>拿到这个问题，脑海里一共有两种方式</p><ul>    <li>将所有的此集合中的所有的值从redis里面读取出来，然后再存进去。</li>    <li>使用集合的思想进行取差集或并集。如果二者有一个且仅有一个为空那么他们返回的结果为有值的集合</li></ul><a id="more"></a><h2 id="Redis-在集合中复制键"><a href="#Redis-在集合中复制键" class="headerlink" title="Redis:在集合中复制键"></a>Redis:在集合中复制键</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>将所有的此集合中的所有的值从redis里面读取出来，然后再存到目标库中。</p><blockquote>    <p>思路清晰，不再过多赘述。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr5bko8fz0j309m02k744.jpg" alt=""></p><blockquote>    <p>如果数据较少可以使用SMEMBERS</p></blockquote><p>类型为set,其中有26781027个</p><p>由于直接使用redis命令不是那么方便，故Python代码入下</p><figure class="highlight python">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_redis</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    link redis</span></span><br><span class="line"><span class="string">    :param db:</span></span><br><span class="line"><span class="string">    :return: Redis Link object</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    REDIS_URL = <span class="string">f'redis://:<span class="subst">&#123;RedisPASSWD&#125;</span>@<span class="subst">&#123;RedisHOST&#125;</span>:<span class="subst">&#123;RedisPORT&#125;</span>/<span class="subst">&#123;db&#125;</span>'</span></span><br><span class="line">    redis_client = redis.from_url(REDIS_URL)</span><br><span class="line">    <span class="comment"># 验证是否连接</span></span><br><span class="line">    <span class="comment"># print(redis_client.info())</span></span><br><span class="line">    <span class="keyword">return</span> redis_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_val</span><span class="params">(key: str, step)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    get values</span></span><br><span class="line"><span class="string">    :param step:</span></span><br><span class="line"><span class="string">    :param key:str</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        redis_client = conn_redis(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#  获取键的大小</span></span><br><span class="line">        key_size = redis_client.scard(key)</span><br><span class="line">        key_type = redis_client.type(key)</span><br><span class="line">        logger.info(<span class="string">f'Key Name: <span class="subst">&#123;key&#125;</span>, key Type: <span class="subst">&#123;key_type&#125;</span> Key Size: <span class="subst">&#123;key_size&#125;</span>'</span>)</span><br><span class="line">        page = int(key_size // step) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, page + <span class="number">1</span>):</span><br><span class="line">            result = redis_client.sscan(key, i, <span class="string">'*'</span>, step)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">yield</span> result</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_newVal</span><span class="params">(db)</span>:</span></span><br><span class="line">    redis_client = conn_redis(db)</span><br><span class="line">    redis_client.sadd(<span class="string">"NewKey"</span>,result)</span><br></pre>            </td>        </tr>    </table></figure><p><strong>方案一优化</strong></p><blockquote>    <p>sadd(“NewKey”,result)还是比较慢。使用pipeline</p></blockquote><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>由于是集合，可以使用集合的操作。</p><blockquote>    <p>任何集合的本身的补、并、差都是本身</p>    <p>1.集合的交集&amp; ,set.intersection()</p>    <p>2.集合的并集 | ,set. union()</p>    <p>3.集合的差集 set.difference(s2) 将集合s1里去掉和s2交集的部分</p>    <p>4.集合的交叉补集 set.symmetric_difference() 并集里去掉交集的部分</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr5exvf9xmj30q30aywej.jpg" alt=""></p><p>创建集合 1，2，3</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr5f96nq49j30fs055mx0.jpg" alt=""></p><p>取给定集合的并集存储在目标集合中</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr5fbdbwbsj30ct06gt8m.jpg" alt=""></p><p>取给差集合的并集存储在目标集合中</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr5fe8xoj1j30dz043mx0.jpg" alt=""></p><p>这样就可以实现类似于copy的效果</p><p>所使用到的Redis命令</p><figure class="highlight shell">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">help</span> SMEMBERS</span></span><br><span class="line">SMEMBERS key</span><br><span class="line">summary: Get all the members in a set</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: set</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">help</span> SSCAN</span></span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">summary: Incrementally iterate Set elements 增量迭代集合元素</span><br><span class="line">since: 2.8.0</span><br><span class="line">group: set</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">help</span> SUNIONSTORE</span></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line">summary: Add multiple sets and store the resulting set in a key 添加多个集合并将生成的集合存储在一个键中</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: set</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">help</span> SDIFFSTORE</span></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br><span class="line">summary: Subtract multiple sets and store the resulting set in a key 减去多个集合并将得到的集合存储在一个键中</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: set</span><br></pre>            </td>        </tr>    </table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>采用先取后存，以及集合的本身是本身的特性对于集合实现复制操作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;问题描述: 由于某种原因，我必须需要将某个集合的键（Key）复制一份副本。并移动到目标库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拿到这个问题，脑海里一共有两种方式&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;将所有的此集合中的所有的值从redis里面读取出来，然后再存进去。&lt;/li&gt;
    &lt;li&gt;使用集合的思想进行取差集或并集。如果二者有一个且仅有一个为空那么他们返回的结果为有值的集合&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://paynewu.com/categories/Redis/"/>
    
      <category term="redis" scheme="https://paynewu.com/categories/Redis/redis/"/>
    
      <category term="小技巧" scheme="https://paynewu.com/categories/Redis/redis/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Redis" scheme="https://paynewu.com/tags/Redis/"/>
    
      <category term="redis" scheme="https://paynewu.com/tags/redis/"/>
    
      <category term="小技巧" scheme="https://paynewu.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Tampermonkey安装与使用</title>
    <link href="https://paynewu.com/ckss9yc9i002txngo9x8c56ox.html"/>
    <id>https://paynewu.com/ckss9yc9i002txngo9x8c56ox.html</id>
    <published>2021-06-03T10:52:47.000Z</published>
    <updated>2021-08-24T02:19:30.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h2><p><strong>Tampermonkey</strong> 是一款免费的浏览器扩展和最为流行的用户脚本管理器，虽然有些受支持的浏览器拥有原生的用户脚本支持，但 Tampermonkey 将在您的用户脚本管理方面提供更多的便利。 它提供了诸如便捷脚本安装、自动更新检查、标签中的脚本运行状况速览、内置的编辑器等众多功能， 同时Tampermonkey还有可能正常运行原本并不兼容的脚本。</p><a id="more"></a><h3 id="Tampermonkey的安装"><a href="#Tampermonkey的安装" class="headerlink" title="Tampermonkey的安装"></a>Tampermonkey的安装</h3><h4 id="方式一-Chrome商店直接下载"><a href="#方式一-Chrome商店直接下载" class="headerlink" title="方式一 Chrome商店直接下载"></a>方式一 Chrome商店直接下载</h4><p>Chrome商店 -&gt; 搜索 Tampermonkey -&gt; Tampermonkey 安装即可</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4arkuzzmj30yd08jdge.jpg" alt=""></p><p>一般情况下是无法下载的，除非你能。。。</p><h4 id="方式二：第三方网站进行插件文件下载"><a href="#方式二：第三方网站进行插件文件下载" class="headerlink" title="方式二：第三方网站进行插件文件下载"></a>方式二：第三方网站进行插件文件下载</h4><p>进入<a href="https://www.crx4chrome.com/crx/755/进行安装文件的下载，下载完成后。打开拓展程序(Chrome用户选项框" target="_blank" rel="noopener">https://www.crx4chrome.com/crx/755/进行安装文件的下载，下载完成后。打开拓展程序(Chrome用户选项框</a> -&gt; 更多工具 -&gt; 拓展程序)</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4ay74m2aj30kd0fkt95.jpg" alt=""></p><p>进入如下图所示的界面</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4ayxb6y3j31fo0mgwgp.jpg" alt=""></p><p>打开右上角的 <strong>开发者模式</strong>，将已经下载的文件拖拽至上图所示的界面。即可完成安装。</p><h3 id="使用第三方脚本"><a href="#使用第三方脚本" class="headerlink" title="使用第三方脚本"></a>使用第三方脚本</h3><p>进入greasyfork <a href="https://greasyfork.org/zh-CN/scripts" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts</a> 获取需要的插件脚本即可</p><h3 id="自定义开发脚本"><a href="#自定义开发脚本" class="headerlink" title="自定义开发脚本"></a>自定义开发脚本</h3><p>鼠标点击<strong>Tampermonkey</strong>图标呼出其选项卡，点击添加脚本。即可进入新建脚本界面。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4baf3mybj31fj0i3gmi.jpg" alt=""></p><h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><figure class="highlight javascript">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @key value</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br></pre>            </td>        </tr>    </table></figure><h4 id="字段释意："><a href="#字段释意：" class="headerlink" title="字段释意："></a>字段释意：</h4><h5 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h5><p>@name：脚本的名字(自定义)</p><p>@author 作者。该脚本的作者。可使用默认的you，或者你的名字</p><p>@description 脚本描述（类似于编程中的注释，阐述该脚本的作用等）</p><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>@namespace 脚本的命名空间(通常使用默认<a href="http://tampermonkey.net/，也可指定" target="_blank" rel="noopener">http://tampermonkey.net/，也可指定</a>)</p><p>@homepage, @homepageURL, @website and @source 在选项页面使用的作者主页，用于从脚本名称链接到给定页面。如果@namespace 标记以“<a href="http://”开头，则其内容也将用于此目的。" target="_blank" rel="noopener">http://”开头，则其内容也将用于此目的。</a></p><h5 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h5><p>@version 脚本版本号</p><p>@updateURL：用户脚本的更新 URL。 注意：需要一个@version 标签才能使更新检查工作</p><p>@downloadURL：URL定义检测到更新时下载脚本的 URL。如果使用值 none，则不会进行更新检查。</p><p>@supportURL 定义用户可以报告问题并获得个人支持的 URL。</p><h5 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h5><p>@include</p><p>脚本允许运行的页面，可以是多个标签实例。 支持正则语句</p><blockquote>    <p>注意：</p>    <p>@include 不支持 URL 哈希参数，必须匹配没有哈希参数的路径并使用</p></blockquote><p>示例：</p><figure class="highlight javascript">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>            </td>            <td class="code">                <pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         New Userscript</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @include      https://www.tampermonkey.net/documentation.php?ext=dhdg</span></span><br><span class="line"><span class="comment">// @icon         https://www.google.com/s2/favicons?domain=tampermonkey.net</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="comment">// Your code here...</span></span><br><span class="line">    alert(<span class="string">'HEllo'</span>)</span><br><span class="line">&#125;)();</span><br></pre>            </td>        </tr>    </table></figure><p>保存后，当我们访问<a href="https://www.tampermonkey.net/documentation.php?ext=dhdg的时候将会弹出Hello。如下图所示" target="_blank" rel="noopener">https://www.tampermonkey.net/documentation.php?ext=dhdg的时候将会弹出Hello。如下图所示</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4c8ojzwij30x204njre.jpg" alt=""></p><p>当@match 为 <strong>*</strong> 时，当访问任何一个页面都会alter出对应的内容来。如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4c9uenmkj30wy04nglk.jpg" alt=""></p><p>@match</p><p>@match 与 @include 非常相似，然而@match更安全。它对 * 字符的含义设置了更严格的规则。</p><p>@match 与 @include他们都是匹配基于一组由匹配模式定义的 URL。匹配模式本质上是以允许的方案开头的 URL。匹配模式本质上是以允许的方案（http、https、file 或 ftp，并且可以包含“*”字符）开头的 URL。特殊模式匹配以允许的方案开头的任何 URL。</p><p>‘<em>‘ 的含义取决于它是在方案、主机还是路径部分。如果方案是 </em>，则它匹配 http 或 https，而不匹配 file、ftp 或 urn。如果主机只是 <em>，那么它匹配任何主机。如果主机是 </em>.<em>hostname</em>，则它匹配指定的主机或其任何子域。在路径部分，每个 ‘*’ 匹配 0 个或多个字符。</p><blockquote>    <p>@match 与 @include区别请参考</p>    <p><a href="https://wiki.greasespot.net/Metadata_Block#.40match" target="_blank" rel="noopener">https://wiki.greasespot.net/Metadata_Block#.40match</a></p>    <p>匹配规则</p>    <p><a href="https://developer.chrome.com/docs/extensions/mv3/match_patterns/" target="_blank" rel="noopener">https://developer.chrome.com/docs/extensions/mv3/match_patterns/</a></p></blockquote><p><strong>简单来说推荐使用@match</strong></p><p>@exclude</p><p>不匹配，相当于访问黑名单。如果访问了@exclude中与之匹配的内容则不执行自定义的JavaScript代码</p><p>@exclude优先权大于match和@include。如果二者都匹配了，那么默认执行@exclude规则。也就是说即是’白名单‘也是’黑名单‘那么默认为’黑名单‘</p><h5 id="第三方链接"><a href="#第三方链接" class="headerlink" title="第三方链接"></a>第三方链接</h5><p>@require</p><p>指向在脚本本身开始运行之前加载和执行的 JavaScript 文件。</p><blockquote>    <p>脚本中可以有任意数量的@require 键。每个 @require 在安装脚本时下载一次，并与脚本一起存储在用户的硬盘驱动器上。指定的 URL 可能与安装脚本的 URL 相关。</p></blockquote><p>@resource</p><p>预加载可由脚本通过 GM_getResourceURL 和 GM_getResourceText 访问的资源。</p><blockquote>    <p>虽然 resourceName 是非语义的，但它应该符合 JavaScript 标识符限制。每个@resource 必须有一个唯一的名称。</p>    <p>每个@resource 在安装脚本时下载一次，并与脚本一起存储在用户的硬盘驱动器上。指定的 URL 可能与安装脚本的 URL 相关。</p>    <p>这些命名资源可以分别通过<a href="https://wiki.greasespot.net/GM_getResourceText" target="_blank" rel="noopener">GM_getResourceText</a>和<a href="https://wiki.greasespot.net/GM_getResourceURL" target="_blank" rel="noopener">GM_getResourceURL</a>访问。</p></blockquote><p>@connect</p><p>此标签定义域（无顶级域），包括允许通过 GM_xmlhttpRequest 检索的子域</p><blockquote>    <p>可以简单的理解为发送请求。GET、POST、HEAD</p></blockquote><p>@run-at</p><p>定义脚本被注入的时刻，与其他脚本处理程序相反， <strong>@run-at</strong> 定义了脚本想要运行的第一个可能时刻。这意味着可能会发生，使用 <strong>@require</strong> 标签的脚本可能会在文档加载后执行，导致获取所需脚本需要很长时间。无论如何，在给定注入时刻之后发生的所有 DOMNodeInserted 和 DOMContentLoaded 事件都被缓存并在注入时传递给脚本。</p><p>@run-at document-start 脚本将尽快注入。<br>@run-at document-body 如果 body 元素存在，脚本将被注入<br>@run-at document-end 该脚本将在调度 DOMContentLoaded 事件时或之后注入。<br>@run-at document-idle 脚本将在 DOMContentLoaded 事件被调度后注入。如果没有给出@run-at 标签，这是默认值。<br>@run-at context-menu 如果在浏览器上下文菜单中单击该脚本（仅限基于 Chrome 的桌面浏览器），则会注入该脚本。</p><blockquote>    <p>建议使用@run-at document-start</p></blockquote><p>@grant</p><p>@grant 用于将 GM_* 函数、unsafeWindow 对象和一些强大的窗口函数列入白名单。如果没有给出@grant 标签，TM 猜测脚本需要。</p><figure class="highlight plain">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br></pre>            </td>            <td class="code">                <pre><span class="line">&#x2F;&#x2F; @grant GM_setValue&#x2F;&#x2F; @grant GM_getValue&#x2F;&#x2F; @grant GM_setClipboard&#x2F;&#x2F; @grant unsafeWindow&#x2F;&#x2F; @grant window.close&#x2F;&#x2F; @grant window.focus&#x2F;&#x2F; @grant window.onurlchange</span><br></pre>            </td>        </tr>    </table></figure><p>由于关闭和聚焦选项卡是一项强大的功能，因此也需要将其添加到 @grant 语句中。</p><p>如果脚本在单页应用程序上运行，那么它可以使用 window.onurlchange 来监听 URL 更改：</p><figure class="highlight plain">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br></pre>            </td>            <td class="code">                <pre><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;UserScript&#x3D;&#x3D;...&#x2F;&#x2F; @grant window.onurlchange&#x2F;&#x2F; &#x3D;&#x3D;&#x2F;UserScript&#x3D;&#x3D;if (window.onurlchange &#x3D;&#x3D;&#x3D; null) &#123;  &#x2F;&#x2F; feature is supported  window.addEventListener(&#39;urlchange&#39;, (info) &#x3D;&gt; ...);&#125;</span><br></pre>            </td>        </tr>    </table></figure><p>如果@grant 后跟“none”，则沙箱将被禁用，脚本将直接在页面上下文中运行。在此模式下，没有 GM_* 功能，但 GM_info 属性将可用。</p><figure class="highlight plain">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br></pre>            </td>            <td class="code">                <pre><span class="line">&#x2F;&#x2F; @grant none</span><br></pre>            </td>        </tr>    </table></figure><blockquote>    <p>推荐使用@grant none</p></blockquote><p>@noframes</p><p>此标记使脚本在主页上运行，但不在 iframe 上运行。</p><div>    <center>        <font color=red size=5px style="font-family: cursive">Reference</br></font>    </center></div><ul>    <li>Tampermonkey官方地址：<a href="https://www.tampermonkey.net/" target="_blank" rel="noopener">https://www.tampermonkey.net/</a></li>    <li>        <p>Tampermonkey官方文档：<a href="https://www.tampermonkey.net/documentation.php?ext=dhdg" target="_blank" rel="noopener">https://www.tampermonkey.net/documentation.php?ext=dhdg</a></p>    </li>    <li>        <p><a href="https://wiki.greasespot.net/Metadata_Block#.40match" target="_blank" rel="noopener">https://wiki.greasespot.net/Metadata_Block#.40match</a></p>    </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Tampermonkey&quot;&gt;&lt;a href=&quot;#Tampermonkey&quot; class=&quot;headerlink&quot; title=&quot;Tampermonkey&quot;&gt;&lt;/a&gt;Tampermonkey&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Tampermonkey&lt;/strong&gt; 是一款免费的浏览器扩展和最为流行的用户脚本管理器，虽然有些受支持的浏览器拥有原生的用户脚本支持，但 Tampermonkey 将在您的用户脚本管理方面提供更多的便利。 它提供了诸如便捷脚本安装、自动更新检查、标签中的脚本运行状况速览、内置的编辑器等众多功能， 同时Tampermonkey还有可能正常运行原本并不兼容的脚本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tampermonkey" scheme="https://paynewu.com/categories/Tampermonkey/"/>
    
    
      <category term="Tampermonkey" scheme="https://paynewu.com/tags/Tampermonkey/"/>
    
  </entry>
  
  <entry>
    <title>爬虫:有什么让人眼前一亮的调试习惯与技巧</title>
    <link href="https://paynewu.com/ckss9yca9004zxngo54q8501f.html"/>
    <id>https://paynewu.com/ckss9yca9004zxngo54q8501f.html</id>
    <published>2021-05-26T01:19:14.000Z</published>
    <updated>2021-08-24T02:19:30.694Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqy39xz1a8j31hc0u077n.jpg" alt=""></p><p>在爬虫调试的时候一个良好的调试习惯,正确的调试技巧。绝对能让您在抓包，定位及JS解密与JS逆向等各种方面事半功倍。</p><a id="more"></a><h2 id="优秀的调试习惯"><a href="#优秀的调试习惯" class="headerlink" title="优秀的调试习惯"></a>优秀的调试习惯</h2><h3 id="无痕模式"><a href="#无痕模式" class="headerlink" title="无痕模式"></a>无痕模式</h3><p>无痕浏览（<a href="https://baike.baidu.com/item/隐私浏览模式" target="_blank" rel="noopener">隐私浏览模式</a>、隐身窗口、InPrevate），是指不留下上网浏览记录的互联网浏览方式。但是，用户下载的文件和建立的收藏夹或书签会保存下来。支持该模式的浏览器包括但不限于百度浏览器，Firefox火狐，搜狗浏览器，360安全浏览器，Avant browser ，世界之窗浏览器，Google Chrome，Internet Explorer 8及更新版本，Edge，Safari.</p><h4 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h4><p> 不记录上网痕迹，保护您的个人隐私</p><p> 不记录 Cookies</p><p> 不记录 Internet <a href="https://baike.baidu.com/item/临时文件" target="_blank" rel="noopener">临时文件</a></p><p> 不记录网页表单数据（用户名、密码、搜索关键词等）</p><p> 不记录撤销页面列表，即历史记录</p><p>等等</p><h4 id="特别提醒"><a href="#特别提醒" class="headerlink" title="特别提醒"></a>特别提醒</h4><p><strong>通过无痕浏览不会影响其他用户、服务器或软件。但请谨防以下情况：</strong></p><ul>    <li>进行无痕浏览时，您下载的文件、新收藏的网址、新修改的浏览器配置将仍然被保留。</li>    <li>因特网服务提供商或雇主还是可以追溯用户访问过的页面。</li>    <li>如果想要清除电脑中的网页浏览痕迹，可以使用安全软件（如360安全卫士）的清理痕迹按钮或手动删除历史记录和缓存文件。</li>    <li>因为是无痕浏览，同样浏览器原先保存的密码和账号同样无法使用，这也会给网络浏览带来不便之处。</li>    <li>网站收集或分享您的相关信息</li>    <li>以提供免费表情图片为名跟踪按键记录的恶意软件</li>    <li>在您浏览过程中的监视者</li>    <li>浏览器插件信息的窃取</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>    <li>IE 和 Chrome 都会在无痕浏览下默认关闭扩展功能，而 FireFox 不一样，在隐私模式下仍然可以使用插件，这无疑又给隐私泄露提供了另一个途径。</li>    <li>所以在关闭Firefox的隐私浏览模式后，您需要检查浏览器插件是否记录了浏览信息，或在隐私模式前暂时禁用不需要开启的插件，否则您的信息可能会被公开</li>    <li>部分插件（如Adobe Flash Player）拥有一套自己的Cookie系统，在隐私模式下 Cookies 仍然会正常工作，甚至在隐私模式下获取的 Cookies 一样是公开可读的。在退出无痕浏览后您需要手动清除Cookis才能做到完全无痕。</li></ul><h4 id="系统隔离技术"><a href="#系统隔离技术" class="headerlink" title="系统隔离技术"></a>系统隔离技术</h4><p>通过一些轻量级的<a href="https://baike.baidu.com/item/虚拟系统" target="_blank" rel="noopener">虚拟系统</a>实现，具体原理：轻量级的虚拟系统可以实现与<a href="https://baike.baidu.com/item/主机系统" target="_blank" rel="noopener">主机系统</a>相互隔离目标，隔离的实现是通过<a href="https://baike.baidu.com/item/镜像" target="_blank" rel="noopener">镜像</a>主机系统环境生成独立的操作系统<a href="https://baike.baidu.com/item/桌面环境" target="_blank" rel="noopener">桌面环境</a>，用户可以在<a href="https://baike.baidu.com/item/虚拟环境" target="_blank" rel="noopener">虚拟环境</a>下安装和使用Internet Explorer，遨游，<a href="https://baike.baidu.com/item/QQ浏览器" target="_blank" rel="noopener">QQ浏览器</a>，Firefox等等<a href="https://baike.baidu.com/item/第三方浏览器" target="_blank" rel="noopener">第三方浏览器</a>，轻量级虚拟系统具有启动资源占用率低，可移动便携方便。这类产品有：VMware Workstation ，Prayaya v3虚拟系统，Ceedo，Macpac等等。</p><h4 id="沙盒技术"><a href="#沙盒技术" class="headerlink" title="沙盒技术"></a>沙盒技术</h4><p>所谓<a href="https://baike.baidu.com/item/沙盒技术" target="_blank" rel="noopener">沙盒技术</a>，具体见百科（<a href="https://baike.baidu.com/item/sandbox" target="_blank" rel="noopener">sandbox</a>)，沙盒技术可以重定向<a href="https://baike.baidu.com/item/主机系统" target="_blank" rel="noopener">主机系统</a>环境操作到其他的存储空间，以及重定向变量，同时沙盒退出后会自动消失原先的<a href="https://baike.baidu.com/item/虚拟环境" target="_blank" rel="noopener">虚拟环境</a>连接由此达到安装到沙盒中的应用程序不在主机系统中保留痕迹的目的。这类产品有：360安全浏览器，Google 浏览器，火狐浏览器，遨游浏览器等</p><h4 id="为什么建议使用无痕模式进行调试"><a href="#为什么建议使用无痕模式进行调试" class="headerlink" title="为什么建议使用无痕模式进行调试"></a>为什么建议使用无痕模式进行调试</h4><p>当我们使用浏览器访问的时候，难免会由于cookies未及时手动清理，JS缓存等各种情况存在造成调试误差。让人难以快速正确的调试出问题。</p><h3 id="多浏览器"><a href="#多浏览器" class="headerlink" title="多浏览器"></a>多浏览器</h3><p>多浏览器在这里指使用多个不同的浏览器进行调试，而非仅仅使用Chrome。其中的益处不言而喻，多浏览器能够快速的找到不同。</p><h3 id="优秀的调试方式与技巧"><a href="#优秀的调试方式与技巧" class="headerlink" title="优秀的调试方式与技巧"></a>优秀的调试方式与技巧</h3><blockquote>    <p>优秀的调试技巧，能够让你事半功倍，极大的降低调试难度。</p></blockquote><h4 id="巧用DevTools搜索工具快速定位数据接口"><a href="#巧用DevTools搜索工具快速定位数据接口" class="headerlink" title="巧用DevTools搜索工具快速定位数据接口"></a>巧用DevTools搜索工具快速定位数据接口</h4><p>当我们确定了需要抓取数据的目标网站，往往是这种情况。里面参杂了不少不包含数据的包，例如这样。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqvq9pigxwj312c0kqwfu.jpg" alt=""></p><p>那么如果需要过去该页面数据，就必须找到对应的数据包，一个一个去找明显不现实。有什么方法可以快的定位到该数据包呢？我们可以这样操作。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxwjtd2efj30d60dv0t0.jpg" alt=""></p><p>第一步：鼠标左键点击“放大镜”，呼出Search面板。</p><p>第二步：搜索对应的内容，支持大小写敏感，正则</p><p>第三步：根据结果，鼠标双击对应内容，即可直接跳至对应包位置</p><h4 id="巧用重放攻击快速定位加密位置"><a href="#巧用重放攻击快速定位加密位置" class="headerlink" title="巧用重放攻击快速定位加密位置"></a>巧用重放攻击快速定位加密位置</h4><p>当网站有相关的验证时，由于参数过多，无法快速的确定哪个参数才是真正决定是否为真实数据的时候，那么我们可以采用重放攻击的方式。进行测试从而快速定位加密位置。</p><h5 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h5><p>重放攻击(Replay Attacks)又称重播攻击、回放攻击，是指攻击者发送一个目的<a href="https://baike.baidu.com/item/主机/455151" target="_blank" rel="noopener">主机</a>已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。攻击者利用<a href="https://baike.baidu.com/item/网络监听/10914318" target="_blank" rel="noopener">网络监听</a>或者其他方式盗取认证凭据，之后再把它重新发给<a href="https://baike.baidu.com/item/认证服务器" target="_blank" rel="noopener">认证服务器</a>。重放攻击在任何网络通过程中都可能发生，是计算机世界<a href="https://baike.baidu.com/item/黑客/118396" target="_blank" rel="noopener">黑客</a>常用的攻击方式之一。 </p><h5 id="重放攻击的原理"><a href="#重放攻击的原理" class="headerlink" title="重放攻击的原理"></a>重放攻击的原理</h5><p>重放攻击的基本原理就是把以前<a href="https://baike.baidu.com/item/窃听/1624599" target="_blank" rel="noopener">窃听</a>到的数据原封不动地重新发送给接收方。很多时候，网络上传输的数据是<a href="https://baike.baidu.com/item/加密/752748" target="_blank" rel="noopener">加密</a>过的，此时窃听者无法得到数据的准确意义。但如果他知道这些数据的作用，就可以在不知道数据内容的情况下通过再次发送这些数据达到愚弄接收端的目的。例如，有的系统会将鉴别信息进行简单加密后进行传输，这时攻击者虽然无法窃听<a href="https://baike.baidu.com/item/密码/65553" target="_blank" rel="noopener">密码</a>，但他们却可以首先截取加密后的口令然后将其重放，从而利用这种方式进行有效的攻击。再比如，假设网上存款系统中，一条消息表示用户支取了一笔存款，攻击者完全可以多次发送这条消息而偷窃存款</p><h5 id="重放攻击的类型"><a href="#重放攻击的类型" class="headerlink" title="重放攻击的类型"></a>重放攻击的类型</h5><p><strong>1.根据重放消息的接收方与消息的原定接收方的关系，重放攻击可分为3种：</strong> </p><p>第一种是直接重放，即重放给原来的验证端，直接重放的发送方和接收方均不变。 </p><p>第二种是反向重放，将原本发给接收方的消息反向重放给发送方。 </p><p>第三种是第三方重放，将消息重放给域内的其他验证端。 </p><p><strong>2.基于重放法发生在什么回合，可以将重放攻击分为两类：</strong> </p><p>(1)在当前回合外攻击中，重放的消息来自协议当前回合之外，因此至少涉及协议的两个回合运行，可以并发也可以顺序地实现。 </p><p>①交错攻击需要两回合或多回合同时执行<a href="https://baike.baidu.com/item/协议/13020269" target="_blank" rel="noopener">协议</a>，著名的例子是Lowe对NSPK协议的攻击。 [5] </p><p>②经典重放也涉及当前回合外执行协议，但不要求同时执行协议。攻击者存储在前面的回合中所传送的消息，并抓住机会重放它们，对协议的当前回合进行攻击。Denning和Sacco对NSSK协议的攻击，就是经典重放的一个著名例子。 </p><p>(2)在当前回合内攻击中，重放的消息来自协议当前回合。 </p><p><strong>3.考查攻击者对消息重定向，这种分类法称为目的地分类法。分类如下。 </strong> </p><p>(1)偏转重放攻击：重放消息重新定向，发送给不同于原接收者的第三方。这种情形可进一步分为如下子类： </p><p>①重放消息重定向，发送给原发送者，称为反射重放攻击。 </p><p>②重放消息重定向，发送给第三方，即不同于原发送者和原接收方的第三方。</p><p>(2)攻击者通过延时的方法(可能涉及不同的协议回合)，将消息传送给目的地，称为直接重放攻击。 </p><blockquote>    <p>以上信息来自<a href="https://baike.baidu.com/item/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/2229240?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p></blockquote><h5 id="简单操作流程如下"><a href="#简单操作流程如下" class="headerlink" title="简单操作流程如下"></a>简单操作流程如下</h5><p>首先先确定数据包，获取该数据包中的URL。使用代码或脚本间隔一定时间发送网络请求。若根据时间到推移，手动对于请求参数的修改。进行多次验证。基本结构图如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqvr9k38vtj30k90gmt8w.jpg" alt=""></p><p><strong>多次</strong>请求验证，确定加密处。</p><h4 id="妙用中间人攻击进行抓包"><a href="#妙用中间人攻击进行抓包" class="headerlink" title="妙用中间人攻击进行抓包"></a>妙用中间人攻击进行抓包</h4><p>在很多情况下一个DevTools解决所有，但也有很少部分针对此进行了限制。</p><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p>中间人攻击（Man-in-the-MiddleAttack，简称“<a href="https://baike.baidu.com/item/MITM攻击/15637385" target="_blank" rel="noopener">MITM攻击</a>”）是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。</p><p>中间人原理图，如下所示</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw5udebogj30v80ggq2w.jpg" alt=""></p><p>使用中间人进行”代理“拦截和转发。从而实现抓包的目的.</p><h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h5><p>抓包抓不到？</p><blockquote>    <p>多体现在Android抓包</p></blockquote><p>强制代理</p><p>VPN转发</p><h4 id="各种断点助力调试"><a href="#各种断点助力调试" class="headerlink" title="各种断点助力调试"></a>各种断点助力调试</h4><blockquote>    <p>程序断点的相关概念便不在此过多赘述，若想了解请自行搜搜</p></blockquote><p><strong>DOM断点</strong></p><p>DOM断点一般有三种方式，subtree modification、attribute modification、node removal。如下图所示，</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw795aqmuj30n00oign0.jpg" alt="">在这里使用下了一个node removal断点。那么当我们删除此节点的时候将触发断点。如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw7bttdw2j31cx0u00vm.jpg" alt=""></p><p>JS断点</p><p>Js断点有两种，一种是Js运行断点，一种是Js调试断点。</p><p>Js运行断点：当网页执行Js的时便会立即进入调试模式。操作方式如下</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxflr7ihpj31gt0u0q54.jpg" alt=""></p><p>首先打开开发者工具，</p><p>然后进入source选项卡</p><p>然后进入右栏中 Event Listener Breakpoints中</p><p>最后勾选Script</p><p>即可开启，当网站运行时。便会进入debugger模式</p><p>Js调试断点: 此断点需要开发者的去下</p><p>首先打开开发者工具，</p><p>然后进入source选项卡</p><p>找到对应位置，鼠标左键点击。</p><p>即可完成</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxfvabvc5j31wc0p2q5u.jpg" alt=""></p><p>若网页运行到此处，便会触发断点。</p><h4 id="XHR断点"><a href="#XHR断点" class="headerlink" title="XHR断点"></a>XHR断点</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a>（XHR）是一种创建<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/AJAX" target="_blank" rel="noopener">AJAX</a>请求的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/JavaScript" target="_blank" rel="noopener">JavaScript </a><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/API" target="_blank" rel="noopener">API</a>。它的方法提供了在<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Browser" target="_blank" rel="noopener">浏览器</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Server" target="_blank" rel="noopener">服务器</a>之间发送请求的能力。</p><p>当网站是Ajax请求当时候，XHR断点将是一个非常不错的调试技巧。</p><p>XHR断点也有两种，一种是发生任何XHR请求的时候都出发断点，另一种是特定条件的XHR断点。</p><p>操作如下</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxg88pojcj31110hqt90.jpg" alt=""></p><p>打开DevTools，进入source选项卡。点开XHR/fetch Breakpoints。</p><p>鼠标左键点击旁边的“+”号，直接Enter即可完成。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxg8o1vr1j305c01bdfm.jpg" alt=""></p><p>特定XHR断点：</p><p>鼠标左键点击旁边的“+”号，在输入栏中输入限定条件，如Id，输入完成后Enter</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxgedm9qxj3060018dfm.jpg" alt=""></p><h4 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h4><p>Hook 又叫作钩子技术，它就是在程序运行的过程中，对其中的某个方法进行重写，在原有的方法前后自定义的代码。相当于在系统没有调用该函数之前，钩子程序就先捕获该消息，可以先得到控制权，这时钩子函数便可以加工处理（改变）该函数的执行行为。执行函数后释放控制权限，继续运行原有逻辑。</p><p>示意图如下，</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxgrt9q3sj30kv0j3wej.jpg" alt=""></p><figure class="highlight javascript">    <table>        <tr>            <td class="gutter">                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>            </td>            <td class="code">                <pre><span class="line">(func(args...)&#123;</span><br><span class="line"> <span class="comment">// Hook 逻辑</span></span><br><span class="line"> &#125;)(args...)</span><br></pre>            </td>        </tr>    </table></figure><p>常实现的有 Devtools Hook，本地文件映射Hook，插件Tempermonkey Hook</p><p> <strong>Devtools 直接注入:</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxh7igr7sj307f03wmx0.jpg" alt=""></p><p> Devtools 直接注入的优点：可以直接把Hook函数copy至console中，直接运行。简单便捷。</p><p>缺点：比较难修改已经注入的Hook。难以复用。</p><p><strong>文件映射Hook</strong></p><p>在本地书写Hook函数，后使用DevTools中source选项卡中的Overrides进行文件映射。当网页运行满足Hook条件时候，便会触发Hook函数。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxhf2qvgnj30he03xglj.jpg" alt=""></p><p><strong>Tempermonkey Hook</strong></p><p><em>Tampermonkey</em> 是第一个可以用来让 Chrome 支持更多 UserScript 的 Chrome 扩展，它可以加入更多的 Chrome 本身不支持的用户脚本功能。Tempermonkey下载与使用请自行搜索</p><p>优点：可定制化，通用化。有针对的进行开发。</p><p>缺点：需要下载，需要学习Tempermonkey 的使用</p><h4 id="JS注入"><a href="#JS注入" class="headerlink" title="JS注入"></a>JS注入</h4><p>当我们访问网站时候，一般情况下会将Js缓存到本地，进行相关运行。那么说如果我将本地的保存，修改其中逻辑，并覆盖其服务器下发的Js。这就是注入攻击</p><p>其原理是保存服务器下发的Js文件形成类似于“缓存”的功能，修改并覆盖下发Js文件即可完成。</p><p>常见的实现方法有三种</p><ol>    <li>        <p>DevTools中source选项卡中的Overrides进行文件映射</p>    </li>    <li>        <p>Tempermonkey</p>        <blockquote>            <p>以上操作，请参考上文</p>        </blockquote>    </li>    <li>        <p>Charles或其他第三方工具</p>        <p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxhxiph0mj305a0j5jrl.jpg" alt=""></p>    </li></ol><p> <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxhxz28n1j30cx0budfw.jpg" alt=""></p><h4 id="点位插桩调试"><a href="#点位插桩调试" class="headerlink" title="点位插桩调试"></a>点位插桩调试</h4><p>其核心原理为：监听核心变量</p><p>首先在对应位置鼠标右键呼出，选择add conditional break…</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxia1wn4vj306s04ht8o.jpg" alt=""></p><p>输入监听值</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxi9firu2j30gy02pq2t.jpg" alt=""></p><p>放入 Logpoint中。完成后运行js即可在对应级别内看到日志输出</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxigqz9fpj306o06vdfp.jpg" alt=""></p><center>    <font color=red size=5px style="font-family: cursive">希望以上方法与技巧对你有所帮助</br></font>    <font color=red size=3px style="font-family: cursive">知道的越多，不知道的越多。</font></center><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqy30zuc6nj31c20mgn13.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008i3skNgy1gqy39xz1a8j31hc0u077n.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在爬虫调试的时候一个良好的调试习惯,正确的调试技巧。绝对能让您在抓包，定位及JS解密与JS逆向等各种方面事半功倍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/"/>
    
      <category term="JavaScript" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/JavaScript/"/>
    
      <category term="技巧" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/JavaScript/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="JS" scheme="https://paynewu.com/categories/%E7%88%AC%E8%99%AB/Crawler/JavaScript/%E6%8A%80%E5%B7%A7/JS/"/>
    
    
      <category term="爬虫" scheme="https://paynewu.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Crawler" scheme="https://paynewu.com/tags/Crawler/"/>
    
      <category term="Web Spider" scheme="https://paynewu.com/tags/Web-Spider/"/>
    
      <category term="数据采集" scheme="https://paynewu.com/tags/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"/>
    
      <category term="JS" scheme="https://paynewu.com/tags/JS/"/>
    
      <category term="Chrome" scheme="https://paynewu.com/tags/Chrome/"/>
    
      <category term="JavaScript" scheme="https://paynewu.com/tags/JavaScript/"/>
    
      <category term="技巧" scheme="https://paynewu.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>
